\documentclass[12pt,A4]{extarticle}	

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage[german]{babel}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{calc, decorations.text}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

% For binary trees
\usepackage{forest}
\usepackage{adjustbox}

\usepackage{filecontents}

\begin{filecontents}{\jobname.bib}
  @inproceedings{jouxKeyExchange,
    author = {Joux, Antoine},
    year = {2006},
    month = {12},
    pages = {385-393},
    title = {A One Round Protocol for Tripartite Diffie–Hellman},
    volume = {17},
    isbn = {978-3-540-67695-9},
    journal = {Journal of Cryptology},
    doi = {10.1007/10722028_23}
    }
\end{filecontents}

\newcommand{\lectureTitle}{Authentisierung und Verschlüsselung [WIP]}
\newcommand{\semester}{Sommersemester 2023}

\newcommand{\titleSize}{\LARGE}

\input{../shared/summary-boilerplate.tex}
\cfoot{\thepage\ $/$ \pageref*{LastPage}}

\definecolor{highlightColor}{RGB}{66, 135, 245}
\newcommand{\highlight}[1]{\textcolor{highlightColor}{\textbf{#1}}}

\definecolor{noticeColor}{RGB}{235, 110, 38}
\newcommand{\notice}[1]{\textcolor{noticeColor}{#1}}

\def\contentsname{\empty}
\addto\captionsgerman{
  \renewcommand{\contentsname}{\empty}
}

\begin{document}
\disclaimer

\tableofcontents
\clearpage

\section{Einführung}
\subsection{Ziel von Kryptographischen Verfahren}
Kryptographische Verfahren sollen \highlight{Authentizität} (Dokument wurde von einer bestimmten Person signiert) und \highlight{Integrität} (Dokument wurde nicht verändert) sicherstellen.

\subsection{Informelle Definition von Signaturen}
\begin{itemize}
  \item{\textbf{asymmetrische} Verfahren}
  \item{Schlüsselpaar $(pk, sk)$}
  \item{Nachricht $m$ wird mit $sk$ signiert und erzeugt Signatur $\sigma$}
  \item{Mit $pk$ kann überprüft werden, ob eine Signatur $\sigma$ gültig für eine Nachricht $m$ ist}
\end{itemize}

\subsection{Digitale Signaturen}
\subsubsection{Definition}
Ein digitales Signaturverfahren für einen Nachrichtenraum $\mathcal{M}$ ist ein Tupel $\Sigma = (Gen, Sign, Vfy)$ von probabilistischen Polyzeit (PPT) Algorithmen:
\begin{itemize}
  \item{$Gen(1^k) \rightarrow (pk, sk)$}
  \item{$Sign(sk, m) \rightarrow \sigma$, $m \in \mathcal{M}$}
  \item{$Vfy(pk, m, \sigma) \in \{0, 1\}$}
\end{itemize}

\subsubsection{Correctness}
\highlight{Correctness} (``Das Verfahren funktioniert''): $\forall (pk, sk) \leftarrow Gen(1^k) \forall m \in \mathcal{M}: Vfy(pk, m, Sign(sk, m)) = 1$

\subsection{Sicherheitsdefinitionen}
Sicherheit besteht aus einem \highlight{Angreifermodell} (was kann der Angreifer tun, welche Angriffsmöglichkeiten stehen zur Verfügung) und einem \highlight{Angreiferziel} (was muss der Angreifer tun, um das Verfahren zu brechen).

\subsubsection{Angreifermodelle}
\begin{enumerate}
  \item{no-message attack (NMA)
              \begin{itemize}
                \item{Angreifer erhält nur $pk$}
              \end{itemize}
        }
  \item{\highlight{non-adaptive chosen-message attack (naCMA)}
              \begin{itemize}
                \item{Angreifer wählt $m_1, \dots, m_q$}
                \item{Angreifer erhält \textbf{danach} $pk$ und Signaturen $\sigma_1, \dots, \sigma_q$}
              \end{itemize}
        }
  \item{\highlight{(adaptive) chosen-message attack (CMA)}
              \begin{itemize}
                \item{Angreifer erhält $pk$}
                \item{Angreifer wählt dann (adaptiv) $m_1, \dots, m_q$ und erhält Signaturen $\sigma_1, \dots, \sigma_q$}
                \item{Adaptiv: Angreifer darf Wahl von $m_i$ abhängig von vorherigen $\sigma_j$ ($j < i$) und $pk$ machen}
              \end{itemize}
        }
\end{enumerate}

\subsubsection{Angreiferziele}
\begin{enumerate}
  \item{Universal Unforgeability (UUF)
              \begin{itemize}
                \item{Nachricht $m$ wird zufällig gewählt}
                \item{Angreifer muss $m$ signieren}
              \end{itemize}
        }
  \item{\highlight{Existential Unforgeablility (EUF)}
              \begin{itemize}
                \item{Angreifer kann Nachricht $m$ beliebig wählen und diese signieren}
              \end{itemize}
        }
\end{enumerate}

In den \textbf{Sicherheitsdefinitionen} werden \textbf{Angreiferziel} und \textbf{Angreifermodell} kombiniert, z.B.
\begin{itemize}
  \item{EUF-CMA}
  \item{EUF-naCMA}
\end{itemize}

\subsection{EUF-CMA-Sicherheitsexperiment}\label{sec:euf-cma}
Bei Sicherheitsexperimenten spielt ein Angreifer $\mathcal{A}$ gegen einen Challenger $\mathcal{C}$. $\mathcal{A}$ gewinnt, falls er die Sicherheit des Verfahrens bricht.\par
$\mathcal{A}$ muss dabei mit einer nicht vernachlässigbaren Wahrscheinlichkeit eine gültige Signatur erzeugen können, ohne den Schlüssel $sk$ zu kennen.

\subsubsection{Visualisierung: EUF-CMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,6) {$\mathcal{C}_\text{EUF-CMA}$};
  \node (B) at (5,6) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={left:$(pk, sk) \leftarrow Gen(1^k)$}] at (0,5) {};
  \node[label={left:$\sigma_i \leftarrow Sign(sk, m_i)$}]  at (0,3) {};

  \draw[decoration={calligraphic brace,amplitude=10pt}, decorate, line width=1.25pt] (5.2,4) -- (5.2,2)
  node[midway, right=0pt, font=\footnotesize] {\begin{minipage}{5cm}\begin{itemize}
        \item{Anfragen nacheinander}
        \item{$q = q(k)$ Anfragen}
        \item{$q$ Polynom}
      \end{itemize}\end{minipage}};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,5) -- (5,4.5) node[midway, above, sloped] {$pk$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_i$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$\sigma_i$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$

\subsubsection{Definition: Vernachlässigbarkeit}
Eine Funktion $negl: \mathbb{N} \rightarrow [0, 1]$ ist \textit{vernachlässigbar}, wenn
\begin{flalign*}
  \forall c \in \mathbb{N} \exists k_0 \in \mathbb{N} \forall k \geq k_0: negl(k) < \frac{1}{k^c}
\end{flalign*}

\subsubsection{Definition: EUF-CMA}\label{sec:DefinitionEUFCMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{EUF-CMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
   & \Pr[\mathcal{A} \text{ gewinnt EUF-CMA-Experiment}]                                                                                    \\
   & = \Pr[\mathcal{A}^{\mathcal{C}_\text{EUF-CMA}}(pk) = (m^*, \sigma^*): Vfy(pk, m^*, \sigma^*) = 1 \land m^* \notin \{m_1, \dots, m_q\}] \\
   & \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{EUF-naCMA-Sicherheitsexperiment}
\subsubsection{Visualisierung: EUF-naCMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,5) {$\mathcal{C}_\text{EUF-naCMA}$};
  \node (B) at (5,5) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={right:\begin{minipage}{5cm}\footnotesize\begin{itemize}
            \item{$q = q(k)$ Nachrichten}
            \item{$q$ Polynom}
          \end{itemize}\end{minipage}}] at (5,4) {};
  \node[label={[align=left]left:$(pk, sk) \leftarrow Gen(1^k)$\\$\forall i: \sigma_i \leftarrow Sign(sk, m_i)$}] at (0,3) {};

  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_1, \dots, m_q$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$pk, \sigma_1, \dots, \sigma_q$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$


\subsubsection{Definition: EUF-naCMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{EUF-naCMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
   & \Pr[\mathcal{A} \text{ gewinnt EUF-naCMA-Experiment}]                                                                                \\
   & = \Pr[\mathcal{A}^{\mathcal{C}_\text{EUF-naCMA}} = (m^*, \sigma^*): Vfy(pk, m^*, \sigma^*) = 1 \land m^* \notin \{m_1, \dots, m_q\}] \\
   & \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{Einmalsignaturen}\label{sec:einmalsignaturen}
\begin{itemize}
  \item{Ziel: Signaturen, die viele Nachrichten signieren können}
  \item{Vorstufe: Signaturen, die nur \textbf{eine} Nachricht \textbf{sicher} signieren können (\highlight{Einmalsignaturen})}
  \item{für jeden \textit{public key} sollte nur eine einzige Signatur ausgestellt werden, sonst evtl. unsicher}
\end{itemize}

\subsubsection{Sicherheitsbegriffe für Einmalsignaturen}
Analog zum vorherigen Kapitel definieren wir \textbf{EUF-1-CMA} und \textbf{EUF-1-naCMA} für Einmalsignaturen.

\subsubsection{Beziehungen zwischen Sicherheitsdefinitionen}
\begin{tikzpicture}
  \node at (0,0) {EUF-1-naCMA};
  \node at (2,0) {$\Leftarrow$};
  \node at (4,0) {EUF-1-CMA};

  \node at (0,1) {$\Downarrow$};
  \node at (4,1) {$\Downarrow$};

  \node at (0,2) {EUF-naCMA};
  \node at (2,2) {$\Leftarrow$};
  \node at (4,2) {EUF-CMA};
\end{tikzpicture}

\textit{Beweis im Skript.}

\subsection{Perfekte Sicherheit}
In den Definitionen, z.B. bei \hyperref[sec:DefinitionEUFCMA]{EUF-CMA} finden sich zwei Einschränkungen, die im folgenden erläutert werden:

\subsubsection{Warum müssen wir uns auf PPT-Angreifer beschränken?}
Durch Brute-Force könnte ein unbeschränkter Angreifer alle Signaturen durchprobieren und so valide Signaturen für beliebige Nachrichten finden, wodurch er beim Sicherheitsexperiment immer gewinnen würde.

\subsubsection{Warum muss die Erfolgswahrscheinlichkeit des Angreifers nur vernachlässigbar sein?}
Die Erfolgswahrscheinlichkeit kann nicht 0 sein, da der Angreifer durch zufälliges Raten eine gültige Signatur für eine beliebige Nachricht finden könnte, wodurch er das Sicherheitsexperiment gewinnt.

\subsection{Erweiterung des Nachrichtenraumes}
Wir konstruieren fast immer Signaturen mit ``kleinem'' Nachrichtenraum, z.B.
\begin{itemize}
  \item{$\mathbb{Z}_p = \{0, \dots, p-1\}$, $p$ prim}
  \item{$\{0, 1\}^{q(k)}$, $q$ Polynom, $k$ Sicherheitsparameter}
\end{itemize}
Unser Ziel ist es jedoch, beliebige Nachrichten, z.B. $\{0, 1\}^*$, zu signieren.

\subsubsection{Hashfunktionen}\label{sec:hashfunktionen}
Eine kryptographische Hashfunktion $H = (Gen_H, Eval_H)$ ist ein Tupel aus zwei PPT-Algorithmen:
\begin{itemize}
  \item{$Gen_H(1^k)$ berechnet $t$, sodass $t$ eine Funktion
              \begin{flalign*}
                H_t: \{0, 1\}^* \rightarrow \mathcal{M}_t
              \end{flalign*}
              spezifiziert}
  \item{$Eval_H(1^k, t,x)$ berechnet $H_t(x)$}
\end{itemize}

\subsubsection{Kollisionsresistenz}
Eine Hashfunktion $H = (Gen_H, Eval_H)$ ist \highlight{kollisionsresistent}, falls für alle $t \leftarrow Gen_H(1^k)$ und für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \Pr[\mathcal{A}(1^k, t) = (x, x'): H_t(x) = H_t(x') \land x \neq x'] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{Signatur mit unbeschränktem Nachrichtenraum (\highlight{Hash-then-Sign})}
Wir wollen nun Signaturen mit unbeschränktem Nachrichtenraum konstruieren. Gegeben:
\begin{itemize}
  \item{$\Sigma' = (Gen', Sign', Vfy')$ mit Nachrichtenraum $\mathcal{M}$}
  \item{kollisionsresistente Hashfunktion $H: \{0,1\}^* \rightarrow \mathcal{M}$}
\end{itemize}
Konstruiere $\Sigma = (Gen, Sign, Vfy)$ mit Nachrichtenraum $\{0,1\}^*$:
\begin{itemize}
  \item{$Gen(1^k)$ berechnet $(pk, sk) \leftarrow Gen'(1^k)$}
  \item{$Sign(sk, m)$ berechnet $\sigma \leftarrow Sign'(sk, H(m))$}
  \item{$Vfy(pk, m, \sigma)$ gibt $Vfy'(pk, H(m), \sigma)$ aus}
\end{itemize}

\section{q-mal Signaturen}
\subsection{Von EUF-naCMA-Sicherheit zu EUF-CMA-Sicherheit}
Gegeben
\begin{itemize}
  \item{ein EUF-naCMA-sicheres Signaturverfahren $\Sigma'$ und}
  \item{ein EUF-1-naCMA-sicheres Einmalsignaturverfahren $\Sigma^{(1)}$}
\end{itemize}
können wir mittels \textbf{Transformation} ein \textbf{EUF-CMA}-sicheres Signaturverfahren $\Sigma$ konstruieren.

\subsubsection{Transformation}
Gegeben:
\begin{itemize}
  \item{EUF-naCMA-sicheres Signaturverfahren $\Sigma' = (Gen', Sign', Vfy')$}
  \item{EUF-1-naCMA-sicheres Signaturverfahren $\Sigma^{(1)} = (Gen^{(1)}, Sign^{(1)}, Vfy^{(1)})$}
\end{itemize}
Konstruiere nun $\Sigma = (Gen, Sign, Vfy)$ wie folgt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                (pk, sk) \coloneqq (pk', sk') \leftarrow Gen'(1^k)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                (pk^{(1)}, sk^{(1)}) & \leftarrow Gen^{(1)}(1^k)                   \\
                \sigma'              & \leftarrow Sign'(sk, pk^{(1)})              \\
                \sigma^{(1)}         & \leftarrow Sign^{(1)} (sk^{(1)} , m)        \\
                \sigma               & \coloneqq (pk^{(1)}, \sigma^{(1)}, \sigma') \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$ gibt 1 aus, wenn\begin{flalign*}
                Vfy'(pk, pk^{(1)}, \sigma') = 1 \land Vfy^{(1)}(pk^{(1)}, m, \sigma^{(1)}) = 1
              \end{flalign*}
              sonst 0 }
\end{itemize}
Es wird also für jede Signatur ein neues Einmalschlüsselpaar erzeugt.

\subsection{Mehrmal-Signaturverfahren aus Einmalsignaturverfahren}
Einmalsignaturverfahren sind effizient und einfach zu konstruieren, daher würden wir gerne eine Variation dieser verwenden, um mehrfach signieren zu können (q-mal-Signaturverfahren).

\subsubsection{Naiver Ansatz: q Schlüsselpaare}
Der naive Ansatz ist, $q$ Schlüsselpaare zu verwenden und einen Zähler $st \in \{1, \dots, q\}$ als Zustand zu verwenden, der auch im Secret Key und in der Signatur vorkommt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq (pk_1, \dots, pk_q)                                               \\
                 & sk \coloneqq (sk_1, \dots, sk_q, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                   \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m) \\
                 & \sigma    \leftarrow (\sigma_i, i)       \\
                 & st        \coloneqq st + 1               \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma = (\sigma_i, i))$: \begin{flalign*}
                Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1
              \end{flalign*}
        }
\end{itemize}

\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(q)$}
  \item{$|sk| \in \Theta(q)$}
  \item{$|\sigma| \in \Theta(1)$}
\end{itemize}

\subsubsection{Zwischenschritt: Hashfunktion verwenden}
Ein weiterer möglicher Ansatz ist die verwendung einer \hyperref[sec:hashfunktionen]{Hashfunktion}
\begin{itemize}
  \item{\notice{$H$ Hashfunktion}}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq \notice{H}(pk_1, \dots, pk_q)                                     \\
                 & sk \coloneqq (sk_1, \dots, sk_q, \notice{pk_1, \dots, pk_q}, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                                         \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m)                       \\
                 & \sigma    \leftarrow (\sigma_i, i, \notice{pk_1, \dots, pk_q}) \\
                 & st        \coloneqq st + 1                                     \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma = (\sigma_i, i))$: \begin{flalign*}
                Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1 \notice{\text{ und } H(pk_1, \dots, pk_q) \stackrel{?}{=} pk}
              \end{flalign*}
        }
\end{itemize}

\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{\notice{$|pk| \in \Theta(1)$}}
  \item{$|sk| \in \Theta(q)$}
  \item{\notice{$|\sigma| \in \Theta(q)$}}
\end{itemize}

\newpage
\subsubsection{Merkle-Bäume}
\highlight{Merkle-Bäume} (auch \textbf{Hash-Bäume} genannt) sind (meist binäre) Bäume, bei denen die Blätter Hashwerte der Daten sind und jeder Knoten darüber aus Hashwerten seiner Kinder besteht:\par
\begin{forest}
  for tree={circle, draw, outer sep=2pt, s sep=1cm, edge={<-, shorten <=-2pt, shorten >=-2pt}, minimum size=1.2cm}
  [{$h_{0,1}$}, label=left:{$pk \coloneqq$}
  [
  {$h_{1,1}$}
    [{$h_{2,1}$}
        [{$h_{3,1}$} [{$pk_1$}, {draw=none}]]
        [{$h_{3,2}$} [{$pk_2$}, {draw=none}]]
    ]
    [{$h_{2,2}$}
        [{$h_{3,3}$} [{$pk_3$}, {draw=none}]]
        [{$h_{3,4}$} [{$pk_4$}, {draw=none}]]
    ]
  ]
  [
  {$h_{1,2}$}
    [{$h_{2,3}$}
        [{$h_{3,5}$} [{$pk_5$}, {draw=none}]]
        [{$h_{3,6}$} [{$pk_6$}, {draw=none}]]
    ]
    [{$h_{2,4}$}
        [{$h_{3,7}$} [{$pk_7$}, {draw=none}]]
        [{$h_{3,8}$} [{$pk_8$}, {draw=none}]]
    ]
  ]
  ]
\end{forest}\par
Der \notice{Co-Pfad} eines Knotens $v$ in einem Binärbaum mit Wurzel $r$ ist die Folge aller Knoten $u_1, \dots, u_n$ wobei $u_i$ der Geschwisterknoten des $i$-ten Knotens auf dem Pfad von $v$ zu $r$ ist:\par
\begin{forest}
  for tree={circle, draw, outer sep=2pt, s sep=1cm, edge={<-, dotted, shorten <=-2pt, shorten >=-2pt}, minimum size=1.2cm}
  [{$h_{0,1}$}, label=left:{$pk \coloneqq$}
  [
  {$h_{1,1}$}, edge=solid
  [{\notice{$h_{2,1}$}}, draw=noticeColor
  [{$h_{3,1}$} [{$pk_1$}, {draw=none}]]
  [{$h_{3,2}$} [{$pk_2$}, {draw=none}]]
  ]
  [{$h_{2,2}$}, edge=solid
  [{$h_{3,3}$}, edge=solid [{\notice{$pk_3$}}, {draw=none}, edge=solid]]
  [{\notice{$h_{3,4}$}}, draw=noticeColor  [{$pk_4$}, {draw=none}]]
  ]
  ]
  [
  {\notice{$h_{1,2}$}}, draw=noticeColor
  [{$h_{2,3}$}
    [{$h_{3,5}$} [{$pk_5$}, {draw=none}]]
    [{$h_{3,6}$} [{$pk_6$}, {draw=none}]]
  ]
  [{$h_{2,4}$}
    [{$h_{3,7}$} [{$pk_7$}, {draw=none}]]
    [{$h_{3,8}$} [{$pk_8$}, {draw=none}]]
  ]
  ]
  ]
\end{forest}\par
Der \notice{Co-Pfad} wird nun in die Signatur hinzugefügt, wodurch der $pk$ von $pk_3$ ausgehend (in diesem Beispiel) in $Vfy$ berechnet werden kann.\par
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq \notice{\text{Baum-Hash}}(pk_1, \dots, pk_q)                      \\
                 & sk \coloneqq (sk_1, \dots, sk_q, \notice{pk_1, \dots, pk_q}, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                                            \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m)                          \\
                 & \sigma    \leftarrow (\sigma_i, i, \notice{pk_i, \text{Co-Pfad}}) \\
                 & st        \coloneqq st + 1                                        \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                 & \notice{\text{Berechne Wurzel } h'}                                                        \\
                 & Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1 \notice{\text{ und } h' \stackrel{?}{=} pk}
              \end{flalign*}
        }
\end{itemize}
\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(1)$}
  \item{$|sk| \in \Theta(q)$}
  \item{\notice{$|\sigma| \in \Theta(\log q)$}}
\end{itemize}
\textbf{\underline{Lemma:}}\par
Wenn $\Sigma^{(1)}$ EUF-1-naCMA-sicher ist und $H$ kollisionsresistent, dann ist das obige Verfahren EUF-q-naCMA-sicher.\par
Wenn $\Sigma^{(1)}$ EUF-1-CMA-sicher ist und $H$ kollisionsresistent, dann ist das obige Verfahren EUF-q-CMA-sicher.



\subsection{Komprimieren des geheimen Schlüssels}
Um den geheimen Schlüssel zu komprimieren, verwenden wir statt echtem Zufall \textit{Pseudozufall} zur Generierung.
\subsubsection{Pseudozufallsfunktion}
Eine Pseudozufallsfunktion oder Pseudorandom function (\textbf{PRF}) ist eine Funktion, die ununterscheidbar von einer zufälligen Funktion ist. Sie erhält dafür zusätzlich einen \textit{Seed} $s$ mit Länge $k$ als Eingabe:
\begin{alignat*}{5}
  \text{PRF: } & \{0,1\}^k \times        &  & \{0,1\}^n \rightarrow  &  & \{0,1\}^l               \\
               & \hspace{0.3cm} \uparrow &  & \hspace{0.3cm}\uparrow &  & \hspace{0.3cm} \uparrow \\
               & \text{Seed } s          &  & \hspace{0.4cm}\alpha   &  & PRF(s, \alpha)
\end{alignat*}

\subsubsection{Schlüsselgenerierung}
Bisher wird unser Schlüssel durch einen \textit{probabilistischen} Algorithmus erzeugt:
\begin{flalign*}
  (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \hspace{1cm} \forall i \in \{1, \dots, q\}
\end{flalign*}
Probabilistische Algorithmen können auch als \textbf{deterministische Algorithmen mit Zufall} $r$ \textbf{als Eingabe} gesehen werden:
\begin{flalign*}
  Gen^{(1)}(1^k) \hspace{1cm} \hat{=} \hspace{1cm} Gen^{(1)}_{\text{det}}(1^k, r)
\end{flalign*}
Damit ist die bishere Schlüsselberechnung äquivalent zu folgender:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, r_i) \hspace{1cm} \forall i \in \{1, \dots, q\} \hspace{1cm} \text{für echt zufällige } r_i
\end{flalign*}
Mit \textbf{echt zufälliger} Funktion $F$ also:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, F(i)) \hspace{1cm} \forall i \in \{1, \dots, q\}
\end{flalign*}
Mit einem zufälligen Seed $s$ können wir den echten Zufall durch Pseudozufall ersetzen:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, PRF(s, i)) \hspace{1cm} \forall i \in \{1, \dots, q\} \hspace{1cm} \text{für } s \stackrel{\$}{\leftarrow} \{0, 1\}^k
\end{flalign*}
Dadurch müssen nur noch der Seed $s$ und der Zähler $st$ im Secret Key gespeichert werden, bei Bedarf können die Schlüsselpaare neu berechnet werden:
\begin{flalign*}
  sk = (\notice{s}, st)
\end{flalign*}
\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(1)$}
  \item{\notice{$|sk| \in \Theta(1)$}}
  \item{$|\sigma| \in \Theta(\log q)$}
\end{itemize}

\section{Chamäleon-Signaturen}
\textbf{Motivation}: Wir wollen Signaturen der Form, dass $A$ die Signatur von $B$ verifizieren kann, jedoch einen anderen $C$ nicht davon überzeugen kann, dass die Signatur von $B$ kam (\highlight{Abstreitbarkeit} genannt).

\subsection{Chamäleon-Hashfunktionen}
\subsubsection{Definition}
Eine \highlight{Chamäleon-Hashfunktion} $CH$ besteht aus zwei PPT-Algorithmen $(Gen_{ch}, TrapColl_{ch})$:
\begin{itemize}
  \item{$Gen_{ch}(1^k)$ gibt $(ch, \tau)$ aus:
              \begin{itemize}
                \item{$ch$ ist eine Funktion $ch: \mathcal{M} \times \mathcal{R} \rightarrow \mathcal{N}$
                            \begin{itemize}
                              \item{$\mathcal{M}$ Nachrichtenraum}
                              \item{$\mathcal{R}$ Zufallsraum}
                              \item{$\mathcal{N}$ Zielraum}
                            \end{itemize}
                      }
                \item{$\tau$ ist eine \highlight{Trapdoor} (Falltür)}
              \end{itemize}
        }
  \item{$TrapColl_{ch}(\tau, m, r, m')$ für $(m, r, m') \in \mathcal{M} \times \mathcal{R} \times \mathcal{M}$ berechnet $r' \in \mathcal{R}$, sodass \begin{flalign*}
                ch(m,r) = ch(m', r')
              \end{flalign*}
        }
\end{itemize}
Wer $\tau$ kennt, kann also Kollisionen berechnen.

\subsubsection{Kollisionsresistenz}
Eine Chamäleon-Hashfunktion $CH = (Gen_{ch}, TrapColl_{ch})$ ist \textbf{kollisionsresistent}, falls für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\substack{(ch, \tau) \leftarrow Gen_{ch}(1^k) \\ \mathcal{A}(1^k, ch) = (m, r, m', r')}: \substack{ch(m, r) = ch(m', r') \\ \land (m, r) \neq (m', r')}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{DLog-Annahme}
Setting:
\begin{itemize}
  \item{Zyklische Gruppe $\mathbb{G} = \langle g \rangle$}
  \item{Endliche Ordnung $|\mathbb{G}| = p$, $p$ prim}
  \item{($\mathbb{G}$ kommutativ)}
  \item{$\mathbb{G}$ abhängig vom Sicherheitsparameter $k$}
\end{itemize}
Das \textbf{DLog-Problem} ist wie folgt definiert:
\begin{itemize}
  \item{Gegeben: Erzeuger $g$ und $y \stackrel{\$}{\leftarrow} \mathbb{G}$}
  \item{Finde $x \in \mathbb{Z}_p: g^x = y$}
\end{itemize}
Die \highlight{DLog-Annahme} ist folgende:\par
$\forall \text{ PPT } \mathcal{A} \text{ gilt:}$
\begin{flalign*}
  \Pr[\mathcal{A}(1^k, g, g^x) = x: \langle g \rangle = \mathbb{G} \text{ zufällig}, x \stackrel{\$}{\leftarrow} \mathbb{Z}_p] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{Chamäleon-Hashfunktion basierend auf DLog}
Wir konstruieren nun eine Chamäleon-Hashfunktion basierend auf DLog mit einer Gruppe $\mathbb{G}$, $|\mathbb{G}| = p$ prim und $g$ Erzeuger von $\mathbb{G}$:
\begin{itemize}
  \item{$ch$ beschreibt Funktion:
              \begin{itemize}
                \item{$ch: \mathbb{Z}_p \times \mathbb{Z}_p \rightarrow \mathbb{G}$}
                \item{$ch(m, r) \coloneqq g^m \cdot h^r$}
              \end{itemize}
        }
  \item{$Gen(1^k)$:
              \begin{itemize}
                \item{$x \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}
                \item{$h \coloneqq g^x$}
                \item{$ch \coloneqq (g,h)$}
                \item{$\tau \coloneqq x$}
              \end{itemize}}
  \item{$TrapColl_{ch}(\tau, m, r, m')$: Berechnet $r^*$, sodass
              \begin{alignat*}{4}
                 &                 & m + x \cdot r & \equiv m^* + x \cdot r^* & \mod p \\
                 & \Leftrightarrow & r^*           & = \frac{m - m^*}{x} + r  & \mod p
              \end{alignat*} }
\end{itemize}
Damit folgt
\begin{flalign*}
  ch(m, r) = g^m \cdot h^r = g^{m + xr} = g^{m^* + xr^*} = g^{m^*} \cdot h^{r^*} = ch(m^*, r^*)
\end{flalign*}

\textit{Chamäleon-Hashfunktion basierend auf dem RSA-Problem und Shamir’s Trick weggelassen.}

\newpage
\subsection{Chamäleon-Signaturen}
\subsubsection{Konstruktion}
Gegeben sind
\begin{itemize}
  \item{$CH = (Gen_{ch}, TrapColl_{ch})$, $ch: \mathcal{M} \times \mathcal{R} \rightarrow \mathcal{N}$}
  \item{Signatur $\Sigma' = (Gen', Sign', Vfy')$}
\end{itemize}
Konstruiere nun ein Chamäleon-Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk', sk') \leftarrow Gen'(1^k) \\
                 & pk \coloneqq pk'                \\
                 & sk \coloneqq sk'
              \end{flalign*} }
  \item{$Sign(sk,m, ch)$ ($ch$ ist die CH-Fkt. des \textbf{Empfängers}): \begin{flalign*}
                 & r \stackrel{\$}{\leftarrow} \mathcal{R} \\
                 & y \coloneqq ch(m,r)                     \\
                 & \sigma' \coloneqq Sign'(sk, y)          \\
                 & \sigma \coloneqq (\sigma', r)           \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma, ch)$: \begin{flalign*}
                Vfy'(pk, ch(m, r), \sigma') \stackrel{?}{=} 1
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Visualisierung: EUF-CMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,6) {$\mathcal{C}_\text{EUF-CMA}$};
  \node (B) at (5,6) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*, ch) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={[align=left]left:$(pk, sk) \leftarrow Gen(1^k)$\\$(ch, \tau) \leftarrow Gen_{ch}(1^k)$}] at (0,5) {};
  \node[label={left:$\sigma_i \leftarrow Sign(sk, m_i, ch)$}]  at (0,3) {};

  \draw[decoration={calligraphic brace,amplitude=10pt}, decorate, line width=1.25pt] (5.2,4) -- (5.2,2)
  node[midway, right=0pt, font=\footnotesize] {\begin{minipage}{5cm}\begin{itemize}
        \item{Anfragen nacheinander}
        \item{$q = q(k)$ Anfragen}
        \item{$q$ Polynom}
      \end{itemize}\end{minipage}};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,5) -- (5,4.5) node[midway, above, sloped] {$pk, ch$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_i$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$\sigma_i$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*, ch) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$\par
In dieser Variante wird $ch$ vorgegeben, stärkere Sicherheit wird erreicht, wenn $\mathcal{A}$ die Chamäleon-Hashfunktion selbst wählen darf (wie es ein echter Angreifer könnte). \textit{Beweis zur Sicherheit im Skript.}

\subsection{Transformation von Chamäleon-Hashfunktion zu Einmalsignatur}
Jede CH kann zu einem \hyperref[sec:einmalsignaturen]{Einmalsignaturverfahren} transformiert werden.\par
Gegeben $CH = (Gen_{ch}, TrapColl_{ch})$, konstruiere $\Sigma = (Gen, Sign, Vfy)$:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (ch, \tau) \leftarrow Gen_{ch}(1^k)                                             \\
                 & (\tilde{m}, \tilde{r}) \stackrel{\$}{\leftarrow} \mathcal{M} \times \mathcal{R} \\
                 & c \coloneqq ch(\tilde{m}, \tilde{r})                                            \\
                 & pk \coloneqq (ch, c)                                                            \\
                 & sk \coloneqq (\tau, \tilde{m}, \tilde{r})
              \end{flalign*} }
  \item{$Sign(sk, m)$: \begin{flalign*}
                 & r \coloneqq TrapColl_{ch}(\tau, \tilde{m}, \tilde{r}, m) \\
                 & \sigma \coloneqq r                                       \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                c \stackrel{?}{=} ch(m, \sigma)
              \end{flalign*}
        }
\end{itemize}
$\Sigma$ ist EUF-1-naCMA-sicher, wenn $CH$ kollisionsresistent ist.\par
\textit{Dlog-Einmalsignatur aus DLog-CH-Funktion weggelassen.}

\subsection{EUF-CMA verstärken}
Statt wie bisher in \hyperref[sec:euf-cma]{EUF-CMA} $m^* \notin \{m_1, \dots, m_q\}$ zu fordern, könnten wir auch fordern, dann nur das Paar $(m^*, \sigma^*)$ frisch sein muss, die Nachricht aber nicht unbedingt.

\subsubsection{Definition: sEUF-CMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{sEUF-CMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\mathcal{A}^{\mathcal{C}_\text{sEUF-CMA}}(pk) = (m^*, \sigma^*): \substack{Vfy(pk, m^*, \sigma^*) = 1 \hspace{0.5cm} \land \\ (m^*, \sigma^*) \notin \{(m_1, \sigma_1), \dots, (m_q, \sigma_q)\}}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.\par
Mit einem EUF-CMA-sicheren Signaturverfahren und einer CH-Funktion kann ein sEUF-CMA-sicheres Signaturverfahren konstruiert werden. \textit{Details im Skript.}

\newpage
\section{Pairings und BLS-Signaturen}
\subsection{Pairings}
\subsubsection{Definition}
Seien $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$ zyklische Gruppen mit Ordnung $p$ prim. Ein \highlight{Pairing} ist eine \textbf{bilineare} Abbildung
\begin{flalign*}
  \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T
\end{flalign*}
mit den Eigenschaften
\begin{itemize}
  \item{\textbf{Bilinearität}: $\forall g_1, g_1' \in \mathbb{G}_1, g_2, g_2' \in \mathbb{G}_2:$
              \begin{flalign*}
                e(g_1 \cdot g_1', g_2) & = e(g_1, g_2) \cdot e(g_1', g_2) \\
                e(g_1, g_2 \cdot g_2') & = e(g_1, g_2) \cdot e(g_1, g_2')
              \end{flalign*}
              $\Rightarrow e(g_1^a, g_2) = e(g_1, g_2)^a = e(g_1, g_2^a)$
        }
  \item{\textbf{Nicht-Ausgeartetheit} (\textit{non-degenerate}): Für Erzeuger $g_1 \in \mathbb{G}_1, g_2 \in \mathbb{G}_2$ gilt:
              \begin{flalign*}
                e(g_1, g_2) \text{ ist Erzeuger von } \mathbb{G}_T \hspace{2cm} (\stackrel{|\mathbb{G}_T| \text{ prim}}{\Longleftrightarrow} e(g_1, g_2) \neq 1)
              \end{flalign*}
        }
  \item{Effiziente Berechenbarkeit}
\end{itemize}
$\mathbb{G}_1, \mathbb{G}_2$ sind in der Regel \textbf{elliptische Kurven}.

\subsubsection{Typen von Pairing}
\begin{enumerate}
  \item{$\mathbb{G}_1 = \mathbb{G}_2$, \textbf{symmetrisches Pairing}
              \begin{flalign*}
                e: \mathbb{G} \times \mathbb{G} \rightarrow \mathbb{G}_T
              \end{flalign*}
        }
  \item{$\mathbb{G}_1 \neq \mathbb{G}_2$, \textbf{asymmetrisches Pairing} und es existiert ein effizienter, nicht-trivialer Homomorphismus
              \begin{flalign*}
                \psi: \mathbb{G}_1 \rightarrow \mathbb{G}_2
              \end{flalign*}
        }
  \item{$\mathbb{G}_1 \neq \mathbb{G}_2$, \textbf{asymmetrisches Pairing} und es existiert \textit{kein} effizienter, nicht-trivialer Homomorphismus
              \begin{flalign*}
                \psi: \mathbb{G}_1 \rightarrow \mathbb{G}_2
              \end{flalign*}
        }
\end{enumerate}

\subsubsection{Diffie-Hellman-Schlüsselaustausch}
\highlight{Diffie-Hellman} ist ein Protokoll, mit dem \textbf{zwei} Parteien einen gemeinsamen geheimen Schlüssel aushandeln können. Setting: Zyklische Gruppe $\mathbb{G} = \langle g \rangle$ mit Ordnung $p$

\begin{tikzpicture}
  \node[circle,draw=black,label={left:$a \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (A) at (0,0) {$A$};
  \node[circle,draw=black,label={right:$b \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (B) at (10,0) {$B$};

  \draw [->] (A) to [out=15,in=165] node[midway,above,inner sep=2pt] {$g^a$} (B);
  \draw [->] (B) to [out=195,in=-15] node[midway,below,inner sep=2pt] {$g^b$} (A);

  \node (keyA) at (0,-2) {$k = (g^b)^a = g^{ab}$};
  \node (keyB) at (10,-2) {$k = (g^a)^b = g^{ab}$};
\end{tikzpicture}

\textbf{\underline{Ablauf:}}
\begin{enumerate}
  \item{$A$ und $B$ wählen ein zufälliges Element aus $\mathbb{Z}_p$}
  \item{$A$ und $B$ senden dem Gegenüber $g^a$ bzw. $g^b$}
  \item{Beide können sich nun den gemeinsamen Schlüssel $k = g^{ab}$ berechnen}
\end{enumerate}

\subsubsection{Joux 3-Parteien-Schlüsselaustausch}
Joux Verfahren \cite{jouxKeyExchange} ist ähnlich zu Diffie-Hellman, erlaubt aber einen Schlüsselaustausch zwischen 3 Parteien.


\newpage
\bibliographystyle{apalike}
\bibliography{\jobname}
\end{document}