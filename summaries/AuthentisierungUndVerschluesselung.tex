\documentclass[12pt,A4]{extarticle}	

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage[german]{babel}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{calc, decorations.text}
\usetikzlibrary{decorations.pathreplacing,calligraphy}

% For binary trees
\usepackage{forest}
\usepackage{adjustbox}

\usepackage{filecontents}

\begin{filecontents}[overwrite]{\jobname.bib}
  @inproceedings{jouxKeyExchange,
    author = {Joux, Antoine},
    year = {2006},
    month = {12},
    pages = {385-393},
    title = {A One Round Protocol for Tripartite Diffie–Hellman},
    volume = {17},
    isbn = {978-3-540-67695-9},
    journal = {Journal of Cryptology},
    doi = {10.1007/10722028_23}
    }
\end{filecontents}

\newcommand{\lectureTitle}{Authentisierung und Verschlüsselung [WIP]}
\newcommand{\semester}{Sommersemester 2023}

\newcommand{\titleSize}{\LARGE}

\input{../shared/summary-boilerplate.tex}
\cfoot{\thepage\ $/$ \pageref*{LastPage}}

\definecolor{highlightColor}{RGB}{66, 135, 245}
\newcommand{\highlight}[1]{\textcolor{highlightColor}{\textbf{#1}}}

\definecolor{noticeColor}{RGB}{235, 110, 38}
\newcommand{\notice}[1]{\textcolor{noticeColor}{#1}}

\def\contentsname{\empty}
\addto\captionsgerman{
  \renewcommand{\contentsname}{\empty}
}

\begin{document}
\disclaimer

\tableofcontents
\clearpage

\section{Einführung}
\subsection{Ziel von Kryptographischen Verfahren}
Kryptographische Verfahren sollen \highlight{Authentizität} (Dokument wurde von einer bestimmten Person signiert) und \highlight{Integrität} (Dokument wurde nicht verändert) sicherstellen.

\subsection{Informelle Definition von Signaturen}\label{sec:signaturenDefinition}
\begin{itemize}
  \item{\textbf{asymmetrische} Verfahren}
  \item{Schlüsselpaar $(pk, sk)$}
  \item{Nachricht $m$ wird mit $sk$ signiert und erzeugt Signatur $\sigma$}
  \item{Mit $pk$ kann überprüft werden, ob eine Signatur $\sigma$ gültig für eine Nachricht $m$ ist}
\end{itemize}

\subsection{Digitale Signaturen}
\subsubsection{Definition}
Ein digitales Signaturverfahren für einen Nachrichtenraum $\mathcal{M}$ ist ein Tupel $\Sigma = (Gen, Sign, Vfy)$ von probabilistischen Polyzeit (PPT) Algorithmen:
\begin{itemize}
  \item{$Gen(1^k) \rightarrow (pk, sk)$}
  \item{$Sign(sk, m) \rightarrow \sigma$, $m \in \mathcal{M}$}
  \item{$Vfy(pk, m, \sigma) \in \{0, 1\}$}
\end{itemize}

\subsubsection{Correctness}
\highlight{Correctness} (``Das Verfahren funktioniert''): $\forall (pk, sk) \leftarrow Gen(1^k) \forall m \in \mathcal{M}: Vfy(pk, m, Sign(sk, m)) = 1$

\subsection{Sicherheitsdefinitionen}
Sicherheit besteht aus einem \highlight{Angreifermodell} (was kann der Angreifer tun, welche Angriffsmöglichkeiten stehen zur Verfügung) und einem \highlight{Angreiferziel} (was muss der Angreifer tun, um das Verfahren zu brechen).

\subsubsection{Angreifermodelle}
\begin{enumerate}
  \item{no-message attack (NMA)
              \begin{itemize}
                \item{Angreifer erhält nur $pk$}
              \end{itemize}
        }
  \item{\highlight{non-adaptive chosen-message attack (naCMA)}
              \begin{itemize}
                \item{Angreifer wählt $m_1, \dots, m_q$}
                \item{Angreifer erhält \textbf{danach} $pk$ und Signaturen $\sigma_1, \dots, \sigma_q$}
              \end{itemize}
        }
  \item{\highlight{(adaptive) chosen-message attack (CMA)}
              \begin{itemize}
                \item{Angreifer erhält $pk$}
                \item{Angreifer wählt dann (adaptiv) $m_1, \dots, m_q$ und erhält Signaturen $\sigma_1, \dots, \sigma_q$}
                \item{Adaptiv: Angreifer darf Wahl von $m_i$ abhängig von vorherigen $\sigma_j$ ($j < i$) und $pk$ machen}
              \end{itemize}
        }
\end{enumerate}

\subsubsection{Angreiferziele}
\begin{enumerate}
  \item{Universal Unforgeability (UUF)
              \begin{itemize}
                \item{Nachricht $m$ wird zufällig gewählt}
                \item{Angreifer muss $m$ signieren}
              \end{itemize}
        }
  \item{\highlight{Existential Unforgeablility (EUF)}
              \begin{itemize}
                \item{Angreifer kann Nachricht $m$ beliebig wählen und diese signieren}
              \end{itemize}
        }
\end{enumerate}

In den \textbf{Sicherheitsdefinitionen} werden \textbf{Angreiferziel} und \textbf{Angreifermodell} kombiniert, z.B.
\begin{itemize}
  \item{EUF-CMA}
  \item{EUF-naCMA}
\end{itemize}

\subsection{EUF-CMA-Sicherheitsexperiment}\label{sec:euf-cma}
Bei Sicherheitsexperimenten spielt ein Angreifer $\mathcal{A}$ gegen einen Challenger $\mathcal{C}$. $\mathcal{A}$ gewinnt, falls er die Sicherheit des Verfahrens bricht.\par
$\mathcal{A}$ muss dabei mit einer nicht vernachlässigbaren Wahrscheinlichkeit eine gültige Signatur erzeugen können, ohne den Schlüssel $sk$ zu kennen.

\subsubsection{Visualisierung: EUF-CMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,6) {$\mathcal{C}_\text{EUF-CMA}$};
  \node (B) at (5,6) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={left:$(pk, sk) \leftarrow Gen(1^k)$}] at (0,5) {};
  \node[label={left:$\sigma_i \leftarrow Sign(sk, m_i)$}]  at (0,3) {};

  \draw[decoration={calligraphic brace,amplitude=10pt}, decorate, line width=1.25pt] (5.2,4) -- (5.2,2)
  node[midway, right=0pt, font=\footnotesize] {\begin{minipage}{5cm}\begin{itemize}
        \item{Anfragen nacheinander}
        \item{$q = q(k)$ Anfragen}
        \item{$q$ Polynom}
      \end{itemize}\end{minipage}};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,5) -- (5,4.5) node[midway, above, sloped] {$pk$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_i$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$\sigma_i$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$

\subsubsection{Definition: Vernachlässigbarkeit}
Eine Funktion $negl: \mathbb{N} \rightarrow [0, 1]$ ist \textit{vernachlässigbar}, wenn
\begin{flalign*}
  \forall c \in \mathbb{N} \exists k_0 \in \mathbb{N} \forall k \geq k_0: negl(k) < \frac{1}{k^c}
\end{flalign*}

\subsubsection{Definition: EUF-CMA}\label{sec:DefinitionEUFCMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{EUF-CMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
   & \Pr[\mathcal{A} \text{ gewinnt EUF-CMA-Experiment}]                                                                                    \\
   & = \Pr[\mathcal{A}^{\mathcal{C}_\text{EUF-CMA}}(pk) = (m^*, \sigma^*): Vfy(pk, m^*, \sigma^*) = 1 \land m^* \notin \{m_1, \dots, m_q\}] \\
   & \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{EUF-naCMA-Sicherheitsexperiment}
\subsubsection{Visualisierung: EUF-naCMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,5) {$\mathcal{C}_\text{EUF-naCMA}$};
  \node (B) at (5,5) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={right:\begin{minipage}{5cm}\footnotesize\begin{itemize}
            \item{$q = q(k)$ Nachrichten}
            \item{$q$ Polynom}
          \end{itemize}\end{minipage}}] at (5,4) {};
  \node[label={[align=left]left:$(pk, sk) \leftarrow Gen(1^k)$\\$\forall i: \sigma_i \leftarrow Sign(sk, m_i)$}] at (0,3) {};

  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_1, \dots, m_q$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$pk, \sigma_1, \dots, \sigma_q$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$


\subsubsection{Definition: EUF-naCMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{EUF-naCMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
   & \Pr[\mathcal{A} \text{ gewinnt EUF-naCMA-Experiment}]                                                                                \\
   & = \Pr[\mathcal{A}^{\mathcal{C}_\text{EUF-naCMA}} = (m^*, \sigma^*): Vfy(pk, m^*, \sigma^*) = 1 \land m^* \notin \{m_1, \dots, m_q\}] \\
   & \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{Einmalsignaturen}\label{sec:einmalsignaturen}
\begin{itemize}
  \item{Ziel: Signaturen, die viele Nachrichten signieren können}
  \item{Vorstufe: Signaturen, die nur \textbf{eine} Nachricht \textbf{sicher} signieren können (\highlight{Einmalsignaturen})}
  \item{für jeden \textit{public key} sollte nur eine einzige Signatur ausgestellt werden, sonst evtl. unsicher}
\end{itemize}

\subsubsection{Sicherheitsbegriffe für Einmalsignaturen}
Analog zum vorherigen Kapitel definieren wir \textbf{EUF-1-CMA} und \textbf{EUF-1-naCMA} für Einmalsignaturen.

\subsubsection{Beziehungen zwischen Sicherheitsdefinitionen}
\begin{tikzpicture}
  \node at (0,0) {EUF-1-naCMA};
  \node at (2,0) {$\Leftarrow$};
  \node at (4,0) {EUF-1-CMA};

  \node at (0,1) {$\Downarrow$};
  \node at (4,1) {$\Downarrow$};

  \node at (0,2) {EUF-naCMA};
  \node at (2,2) {$\Leftarrow$};
  \node at (4,2) {EUF-CMA};
\end{tikzpicture}

\textit{Beweis im Skript.}

\subsection{Perfekte Sicherheit}
In den Definitionen, z.B. bei \hyperref[sec:DefinitionEUFCMA]{EUF-CMA} finden sich zwei Einschränkungen, die im folgenden erläutert werden:

\subsubsection{Warum müssen wir uns auf PPT-Angreifer beschränken?}
Durch Brute-Force könnte ein unbeschränkter Angreifer alle Signaturen durchprobieren und so valide Signaturen für beliebige Nachrichten finden, wodurch er beim Sicherheitsexperiment immer gewinnen würde.

\subsubsection{Warum muss die Erfolgswahrscheinlichkeit des Angreifers nur vernachlässigbar sein?}
Die Erfolgswahrscheinlichkeit kann nicht 0 sein, da der Angreifer durch zufälliges Raten eine gültige Signatur für eine beliebige Nachricht finden könnte, wodurch er das Sicherheitsexperiment gewinnt.

\subsection{Erweiterung des Nachrichtenraumes}
Wir konstruieren fast immer Signaturen mit ``kleinem'' Nachrichtenraum, z.B.
\begin{itemize}
  \item{$\mathbb{Z}_p = \{0, \dots, p-1\}$, $p$ prim}
  \item{$\{0, 1\}^{q(k)}$, $q$ Polynom, $k$ Sicherheitsparameter}
\end{itemize}
Unser Ziel ist es jedoch, beliebige Nachrichten, z.B. $\{0, 1\}^*$, zu signieren.

\subsubsection{Hashfunktionen}\label{sec:hashfunktionen}
Eine kryptographische Hashfunktion $H = (Gen_H, Eval_H)$ ist ein Tupel aus zwei PPT-Algorithmen:
\begin{itemize}
  \item{$Gen_H(1^k)$ berechnet $t$, sodass $t$ eine Funktion
              \begin{flalign*}
                H_t: \{0, 1\}^* \rightarrow \mathcal{M}_t
              \end{flalign*}
              spezifiziert}
  \item{$Eval_H(1^k, t,x)$ berechnet $H_t(x)$}
\end{itemize}

\subsubsection{Kollisionsresistenz}
Eine Hashfunktion $H = (Gen_H, Eval_H)$ ist \highlight{kollisionsresistent}, falls für alle $t \leftarrow Gen_H(1^k)$ und für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \Pr[\mathcal{A}(1^k, t) = (x, x'): H_t(x) = H_t(x') \land x \neq x'] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{Signatur mit unbeschränktem Nachrichtenraum (\highlight{Hash-then-Sign})}\label{sec:hash-then-sign}
Wir wollen nun Signaturen mit unbeschränktem Nachrichtenraum konstruieren. Gegeben:
\begin{itemize}
  \item{$\Sigma' = (Gen', Sign', Vfy')$ mit Nachrichtenraum $\mathcal{M}$}
  \item{kollisionsresistente Hashfunktion $H: \{0,1\}^* \rightarrow \mathcal{M}$}
\end{itemize}
Konstruiere $\Sigma = (Gen, Sign, Vfy)$ mit Nachrichtenraum $\{0,1\}^*$:
\begin{itemize}
  \item{$Gen(1^k)$ berechnet $(pk, sk) \leftarrow Gen'(1^k)$}
  \item{$Sign(sk, m)$ berechnet $\sigma \leftarrow Sign'(sk, H(m))$}
  \item{$Vfy(pk, m, \sigma)$ gibt $Vfy'(pk, H(m), \sigma)$ aus}
\end{itemize}

\section{q-mal Signaturen}
\subsection{Von EUF-naCMA-Sicherheit zu EUF-CMA-Sicherheit}
Gegeben
\begin{itemize}
  \item{ein EUF-naCMA-sicheres Signaturverfahren $\Sigma'$ und}
  \item{ein EUF-1-naCMA-sicheres Einmalsignaturverfahren $\Sigma^{(1)}$}
\end{itemize}
können wir mittels \textbf{Transformation} ein \textbf{EUF-CMA}-sicheres Signaturverfahren $\Sigma$ konstruieren.

\subsubsection{Transformation}
Gegeben:
\begin{itemize}
  \item{EUF-naCMA-sicheres Signaturverfahren $\Sigma' = (Gen', Sign', Vfy')$}
  \item{EUF-1-naCMA-sicheres Signaturverfahren $\Sigma^{(1)} = (Gen^{(1)}, Sign^{(1)}, Vfy^{(1)})$}
\end{itemize}
Konstruiere nun $\Sigma = (Gen, Sign, Vfy)$ wie folgt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                (pk, sk) \coloneqq (pk', sk') \leftarrow Gen'(1^k)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                (pk^{(1)}, sk^{(1)}) & \leftarrow Gen^{(1)}(1^k)                   \\
                \sigma'              & \leftarrow Sign'(sk, pk^{(1)})              \\
                \sigma^{(1)}         & \leftarrow Sign^{(1)} (sk^{(1)} , m)        \\
                \sigma               & \coloneqq (pk^{(1)}, \sigma^{(1)}, \sigma') \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$ gibt 1 aus, wenn\begin{flalign*}
                Vfy'(pk, pk^{(1)}, \sigma') = 1 \land Vfy^{(1)}(pk^{(1)}, m, \sigma^{(1)}) = 1
              \end{flalign*}
              sonst 0 }
\end{itemize}
Es wird also für jede Signatur ein neues Einmalschlüsselpaar erzeugt.

\subsection{Mehrmal-Signaturverfahren aus Einmalsignaturverfahren}
Einmalsignaturverfahren sind effizient und einfach zu konstruieren, daher würden wir gerne eine Variation dieser verwenden, um mehrfach signieren zu können (q-mal-Signaturverfahren).

\subsubsection{Naiver Ansatz: q Schlüsselpaare}
Der naive Ansatz ist, $q$ Schlüsselpaare zu verwenden und einen Zähler $st \in \{1, \dots, q\}$ als Zustand zu verwenden, der auch im Secret Key und in der Signatur vorkommt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq (pk_1, \dots, pk_q)                                               \\
                 & sk \coloneqq (sk_1, \dots, sk_q, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                   \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m) \\
                 & \sigma    \leftarrow (\sigma_i, i)       \\
                 & st        \coloneqq st + 1               \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma = (\sigma_i, i))$: \begin{flalign*}
                Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1
              \end{flalign*}
        }
\end{itemize}

\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(q)$}
  \item{$|sk| \in \Theta(q)$}
  \item{$|\sigma| \in \Theta(1)$}
\end{itemize}

\subsubsection{Zwischenschritt: Hashfunktion verwenden}
Ein weiterer möglicher Ansatz ist die verwendung einer \hyperref[sec:hashfunktionen]{Hashfunktion}
\begin{itemize}
  \item{\notice{$H$ Hashfunktion}}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq \notice{H}(pk_1, \dots, pk_q)                                     \\
                 & sk \coloneqq (sk_1, \dots, sk_q, \notice{pk_1, \dots, pk_q}, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                                         \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m)                       \\
                 & \sigma    \leftarrow (\sigma_i, i, \notice{pk_1, \dots, pk_q}) \\
                 & st        \coloneqq st + 1                                     \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma = (\sigma_i, i))$: \begin{flalign*}
                Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1 \notice{\text{ und } H(pk_1, \dots, pk_q) \stackrel{?}{=} pk}
              \end{flalign*}
        }
\end{itemize}

\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{\notice{$|pk| \in \Theta(1)$}}
  \item{$|sk| \in \Theta(q)$}
  \item{\notice{$|\sigma| \in \Theta(q)$}}
\end{itemize}

\newpage
\subsubsection{Merkle-Bäume}
\highlight{Merkle-Bäume} (auch \textbf{Hash-Bäume} genannt) sind (meist binäre) Bäume, bei denen die Blätter Hashwerte der Daten sind und jeder Knoten darüber aus Hashwerten seiner Kinder besteht:\par
\begin{forest}
  for tree={circle, draw, outer sep=2pt, s sep=1cm, edge={<-, shorten <=-2pt, shorten >=-2pt}, minimum size=1.2cm}
  [{$h_{0,1}$}, label=left:{$pk \coloneqq$}
  [
  {$h_{1,1}$}
    [{$h_{2,1}$}
        [{$h_{3,1}$} [{$pk_1$}, {draw=none}]]
        [{$h_{3,2}$} [{$pk_2$}, {draw=none}]]
    ]
    [{$h_{2,2}$}
        [{$h_{3,3}$} [{$pk_3$}, {draw=none}]]
        [{$h_{3,4}$} [{$pk_4$}, {draw=none}]]
    ]
  ]
  [
  {$h_{1,2}$}
    [{$h_{2,3}$}
        [{$h_{3,5}$} [{$pk_5$}, {draw=none}]]
        [{$h_{3,6}$} [{$pk_6$}, {draw=none}]]
    ]
    [{$h_{2,4}$}
        [{$h_{3,7}$} [{$pk_7$}, {draw=none}]]
        [{$h_{3,8}$} [{$pk_8$}, {draw=none}]]
    ]
  ]
  ]
\end{forest}\par
Der \notice{Co-Pfad} eines Knotens $v$ in einem Binärbaum mit Wurzel $r$ ist die Folge aller Knoten $u_1, \dots, u_n$ wobei $u_i$ der Geschwisterknoten des $i$-ten Knotens auf dem Pfad von $v$ zu $r$ ist:\par
\begin{forest}
  for tree={circle, draw, outer sep=2pt, s sep=1cm, edge={<-, dotted, shorten <=-2pt, shorten >=-2pt}, minimum size=1.2cm}
  [{$h_{0,1}$}, label=left:{$pk \coloneqq$}
  [
  {$h_{1,1}$}, edge=solid
  [{\notice{$h_{2,1}$}}, draw=noticeColor
  [{$h_{3,1}$} [{$pk_1$}, {draw=none}]]
  [{$h_{3,2}$} [{$pk_2$}, {draw=none}]]
  ]
  [{$h_{2,2}$}, edge=solid
  [{$h_{3,3}$}, edge=solid [{\notice{$pk_3$}}, {draw=none}, edge=solid]]
  [{\notice{$h_{3,4}$}}, draw=noticeColor  [{$pk_4$}, {draw=none}]]
  ]
  ]
  [
  {\notice{$h_{1,2}$}}, draw=noticeColor
  [{$h_{2,3}$}
    [{$h_{3,5}$} [{$pk_5$}, {draw=none}]]
    [{$h_{3,6}$} [{$pk_6$}, {draw=none}]]
  ]
  [{$h_{2,4}$}
    [{$h_{3,7}$} [{$pk_7$}, {draw=none}]]
    [{$h_{3,8}$} [{$pk_8$}, {draw=none}]]
  ]
  ]
  ]
\end{forest}\par
Der \notice{Co-Pfad} wird nun in die Signatur hinzugefügt, wodurch der $pk$ von $pk_3$ ausgehend (in diesem Beispiel) in $Vfy$ berechnet werden kann.\par
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \text{ für alle } i \in \{1, \dots, q\} \\
                 & pk \coloneqq \notice{\text{Baum-Hash}}(pk_1, \dots, pk_q)                      \\
                 & sk \coloneqq (sk_1, \dots, sk_q, \notice{pk_1, \dots, pk_q}, st = 1)
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & i         \coloneqq st                                            \\
                 & \sigma_i  \leftarrow Sign^{(1)}(sk_i, m)                          \\
                 & \sigma    \leftarrow (\sigma_i, i, \notice{pk_i, \text{Co-Pfad}}) \\
                 & st        \coloneqq st + 1                                        \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                 & \notice{\text{Berechne Wurzel } h'}                                                        \\
                 & Vfy^{(1)}(pk_i, m, \sigma_i) \stackrel{?}{=} 1 \notice{\text{ und } h' \stackrel{?}{=} pk}
              \end{flalign*}
        }
\end{itemize}
\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(1)$}
  \item{$|sk| \in \Theta(q)$}
  \item{\notice{$|\sigma| \in \Theta(\log q)$}}
\end{itemize}
\textbf{\underline{Lemma:}}\par
Wenn $\Sigma^{(1)}$ EUF-1-naCMA-sicher ist und $H$ kollisionsresistent, dann ist das obige Verfahren EUF-q-naCMA-sicher.\par
Wenn $\Sigma^{(1)}$ EUF-1-CMA-sicher ist und $H$ kollisionsresistent, dann ist das obige Verfahren EUF-q-CMA-sicher.



\subsection{Komprimieren des geheimen Schlüssels}
Um den geheimen Schlüssel zu komprimieren, verwenden wir statt echtem Zufall \textit{Pseudozufall} zur Generierung.
\subsubsection{Pseudozufallsfunktion}
Eine Pseudozufallsfunktion oder Pseudorandom function (\textbf{PRF}) ist eine Funktion, die ununterscheidbar von einer zufälligen Funktion ist. Sie erhält dafür zusätzlich einen \textit{Seed} $s$ mit Länge $k$ als Eingabe:
\begin{alignat*}{5}
  \text{PRF: } & {\{0,1\}}^k \times      &  & {\{0,1\}}^n \rightarrow &  & {\{0,1\}}^l             \\
               & \hspace{0.3cm} \uparrow &  & \hspace{0.3cm}\uparrow  &  & \hspace{0.3cm} \uparrow \\
               & \text{Seed } s          &  & \hspace{0.4cm}\alpha    &  & PRF(s, \alpha)
\end{alignat*}

\subsubsection{Schlüsselgenerierung}
Bisher wird unser Schlüssel durch einen \textit{probabilistischen} Algorithmus erzeugt:
\begin{flalign*}
  (pk_i, sk_i) \leftarrow Gen^{(1)}(1^k) \hspace{1cm} \forall i \in \{1, \dots, q\}
\end{flalign*}
Probabilistische Algorithmen können auch als \textbf{deterministische Algorithmen mit Zufall} $r$ \textbf{als Eingabe} gesehen werden:
\begin{flalign*}
  Gen^{(1)}(1^k) \hspace{1cm} \hat{=} \hspace{1cm} Gen^{(1)}_{\text{det}}(1^k, r)
\end{flalign*}
Damit ist die bishere Schlüsselberechnung äquivalent zu folgender:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, r_i) \hspace{1cm} \forall i \in \{1, \dots, q\} \hspace{1cm} \text{für echt zufällige } r_i
\end{flalign*}
Mit \textbf{echt zufälliger} Funktion $F$ also:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, F(i)) \hspace{1cm} \forall i \in \{1, \dots, q\}
\end{flalign*}
Mit einem zufälligen Seed $s$ können wir den echten Zufall durch Pseudozufall ersetzen:
\begin{flalign*}
  (pk_i, sk_i) \coloneqq Gen^{(1)}_{\text{det}}(1^k, PRF(s, i)) \hspace{1cm} \forall i \in \{1, \dots, q\} \hspace{1cm} \text{für } s \stackrel{\$}{\leftarrow} \{0, 1\}^k
\end{flalign*}
Dadurch müssen nur noch der Seed $s$ und der Zähler $st$ im Secret Key gespeichert werden, bei Bedarf können die Schlüsselpaare neu berechnet werden:
\begin{flalign*}
  sk = (\notice{s}, st)
\end{flalign*}
\underline{\textbf{Eigenschaften bezogen auf Signaturanzahl (q):}}
\begin{itemize}
  \item{$|pk| \in \Theta(1)$}
  \item{\notice{$|sk| \in \Theta(1)$}}
  \item{$|\sigma| \in \Theta(\log q)$}
\end{itemize}

\section{Chamäleon-Signaturen}
\textbf{Motivation}: Wir wollen Signaturen der Form, dass $A$ die Signatur von $B$ verifizieren kann, jedoch einen anderen $C$ nicht davon überzeugen kann, dass die Signatur von $B$ kam (\highlight{Abstreitbarkeit} genannt).

\subsection{Chamäleon-Hashfunktionen}
\subsubsection{Definition}
Eine \highlight{Chamäleon-Hashfunktion} $CH$ besteht aus zwei PPT-Algorithmen $(Gen_{ch}, TrapColl_{ch})$:
\begin{itemize}
  \item{$Gen_{ch}(1^k)$ gibt $(ch, \tau)$ aus:
              \begin{itemize}
                \item{$ch$ ist eine Funktion $ch: \mathcal{M} \times \mathcal{R} \rightarrow \mathcal{N}$
                            \begin{itemize}
                              \item{$\mathcal{M}$ Nachrichtenraum}
                              \item{$\mathcal{R}$ Zufallsraum}
                              \item{$\mathcal{N}$ Zielraum}
                            \end{itemize}
                      }
                \item{$\tau$ ist eine \highlight{Trapdoor} (Falltür)}
              \end{itemize}
        }
  \item{$TrapColl_{ch}(\tau, m, r, m')$ für $(m, r, m') \in \mathcal{M} \times \mathcal{R} \times \mathcal{M}$ berechnet $r' \in \mathcal{R}$, sodass \begin{flalign*}
                ch(m,r) = ch(m', r')
              \end{flalign*}
        }
\end{itemize}
Wer $\tau$ kennt, kann also Kollisionen berechnen.

\subsubsection{Kollisionsresistenz}
Eine Chamäleon-Hashfunktion $CH = (Gen_{ch}, TrapColl_{ch})$ ist \textbf{kollisionsresistent}, falls für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\substack{(ch, \tau) \leftarrow Gen_{ch}(1^k) \\ \mathcal{A}(1^k, ch) = (m, r, m', r')}: \substack{ch(m, r) = ch(m', r') \\ \land (m, r) \neq (m', r')}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{DLog-Annahme}
Setting:
\begin{itemize}
  \item{Zyklische Gruppe $\mathbb{G} = \langle g \rangle$}
  \item{Endliche Ordnung $|\mathbb{G}| = p$, $p$ prim}
  \item{($\mathbb{G}$ kommutativ)}
  \item{$\mathbb{G}$ abhängig vom Sicherheitsparameter $k$}
\end{itemize}
Das \textbf{DLog-Problem} ist wie folgt definiert:
\begin{itemize}
  \item{Gegeben: Erzeuger $g$ und $y \stackrel{\$}{\leftarrow} \mathbb{G}$}
  \item{Finde $x \in \mathbb{Z}_p: g^x = y$}
\end{itemize}
Die \highlight{DLog-Annahme} ist folgende:\par
$\forall \text{ PPT } \mathcal{A} \text{ gilt:}$
\begin{flalign*}
  \Pr[\mathcal{A}(1^k, g, g^x) = x: \langle g \rangle = \mathbb{G} \text{ zufällig}, x \stackrel{\$}{\leftarrow} \mathbb{Z}_p] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{Chamäleon-Hashfunktion basierend auf DLog}
Wir konstruieren nun eine Chamäleon-Hashfunktion basierend auf DLog mit einer Gruppe $\mathbb{G}$, $|\mathbb{G}| = p$ prim und $g$ Erzeuger von $\mathbb{G}$:
\begin{itemize}
  \item{$ch$ beschreibt Funktion:
              \begin{itemize}
                \item{$ch: \mathbb{Z}_p \times \mathbb{Z}_p \rightarrow \mathbb{G}$}
                \item{$ch(m, r) \coloneqq g^m \cdot h^r$}
              \end{itemize}
        }
  \item{$Gen(1^k)$:
              \begin{itemize}
                \item{$x \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}
                \item{$h \coloneqq g^x$}
                \item{$ch \coloneqq (g,h)$}
                \item{$\tau \coloneqq x$}
              \end{itemize}}
  \item{$TrapColl_{ch}(\tau, m, r, m')$: Berechnet $r^*$, sodass
              \begin{alignat*}{4}
                 &                 & m + x \cdot r & \equiv m^* + x \cdot r^* & \mod p \\
                 & \Leftrightarrow & r^*           & = \frac{m - m^*}{x} + r  & \mod p
              \end{alignat*} }
\end{itemize}
Damit folgt
\begin{flalign*}
  ch(m, r) = g^m \cdot h^r = g^{m + xr} = g^{m^* + xr^*} = g^{m^*} \cdot h^{r^*} = ch(m^*, r^*)
\end{flalign*}

\textit{Chamäleon-Hashfunktion basierend auf dem RSA-Problem und Shamir’s Trick weggelassen.}

\newpage
\subsection{Chamäleon-Signaturen}
\subsubsection{Konstruktion}
Gegeben sind
\begin{itemize}
  \item{$CH = (Gen_{ch}, TrapColl_{ch})$, $ch: \mathcal{M} \times \mathcal{R} \rightarrow \mathcal{N}$}
  \item{Signatur $\Sigma' = (Gen', Sign', Vfy')$}
\end{itemize}
Konstruiere nun ein Chamäleon-Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (pk', sk') \leftarrow Gen'(1^k) \\
                 & pk \coloneqq pk'                \\
                 & sk \coloneqq sk'
              \end{flalign*} }
  \item{$Sign(sk,m, ch)$ ($ch$ ist die CH-Fkt. des \textbf{Empfängers}): \begin{flalign*}
                 & r \stackrel{\$}{\leftarrow} \mathcal{R} \\
                 & y \coloneqq ch(m,r)                     \\
                 & \sigma' \coloneqq Sign'(sk, y)          \\
                 & \sigma \coloneqq (\sigma', r)           \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma, ch)$: \begin{flalign*}
                Vfy'(pk, ch(m, r), \sigma') \stackrel{?}{=} 1
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Visualisierung: EUF-CMA-Sicherheitsexperiment}
\begin{tikzpicture}
  \node (A) at (0,6) {$\mathcal{C}_\text{EUF-CMA}$};
  \node (B) at (5,6) {$\mathcal{A}$};
  \node[label={[align=center]below:$Vfy(pk, m^*, \sigma^*, ch) = 1$?\\ $\land$ \\ $m^* \notin \{m_1, \dots, m_q\}$?}] (C) at (0,0) {};
  \node (D) at (5,0) {};

  \draw[dashed] (A) -- (C);
  \draw[dashed] (B) -- (D);

  \node[label={[align=left]left:$(pk, sk) \leftarrow Gen(1^k)$\\$(ch, \tau) \leftarrow Gen_{ch}(1^k)$}] at (0,5) {};
  \node[label={left:$\sigma_i \leftarrow Sign(sk, m_i, ch)$}]  at (0,3) {};

  \draw[decoration={calligraphic brace,amplitude=10pt}, decorate, line width=1.25pt] (5.2,4) -- (5.2,2)
  node[midway, right=0pt, font=\footnotesize] {\begin{minipage}{5cm}\begin{itemize}
        \item{Anfragen nacheinander}
        \item{$q = q(k)$ Anfragen}
        \item{$q$ Polynom}
      \end{itemize}\end{minipage}};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,5) -- (5,4.5) node[midway, above, sloped] {$pk, ch$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,4) -- (0,3.5) node[midway, above, sloped] {$m_i$};

  \draw[->,shorten >=5pt, shorten <=5pt] (0,2.5) -- (5,2) node[midway, above, sloped] {$\sigma_i$};
  \draw[->,shorten >=5pt, shorten <=5pt] (5,1.5) -- (0,1) node[midway, above, sloped] {$m^*, \sigma^*$};
\end{tikzpicture}

$\mathcal{A}$ gewinnt, falls $Vfy(pk, m^*, \sigma^*, ch) = 1$ \textbf{und} $m^* \notin \{m_1, \dots, m_q\}$\par
In dieser Variante wird $ch$ vorgegeben, stärkere Sicherheit wird erreicht, wenn $\mathcal{A}$ die Chamäleon-Hashfunktion selbst wählen darf (wie es ein echter Angreifer könnte). \textit{Beweis zur Sicherheit im Skript.}

\subsection{Transformation von Chamäleon-Hashfunktion zu Einmalsignatur}
Jede CH kann zu einem \hyperref[sec:einmalsignaturen]{Einmalsignaturverfahren} transformiert werden.\par
Gegeben $CH = (Gen_{ch}, TrapColl_{ch})$, konstruiere $\Sigma = (Gen, Sign, Vfy)$:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & (ch, \tau) \leftarrow Gen_{ch}(1^k)                                             \\
                 & (\tilde{m}, \tilde{r}) \stackrel{\$}{\leftarrow} \mathcal{M} \times \mathcal{R} \\
                 & c \coloneqq ch(\tilde{m}, \tilde{r})                                            \\
                 & pk \coloneqq (ch, c)                                                            \\
                 & sk \coloneqq (\tau, \tilde{m}, \tilde{r})
              \end{flalign*} }
  \item{$Sign(sk, m)$: \begin{flalign*}
                 & r \coloneqq TrapColl_{ch}(\tau, \tilde{m}, \tilde{r}, m) \\
                 & \sigma \coloneqq r                                       \\
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                c \stackrel{?}{=} ch(m, \sigma)
              \end{flalign*}
        }
\end{itemize}
$\Sigma$ ist EUF-1-naCMA-sicher, wenn $CH$ kollisionsresistent ist.\par
\textit{Dlog-Einmalsignatur aus DLog-CH-Funktion weggelassen.}

\subsection{EUF-CMA verstärken}
Statt wie bisher in \hyperref[sec:euf-cma]{EUF-CMA} $m^* \notin \{m_1, \dots, m_q\}$ zu fordern, könnten wir auch fordern, dann nur das Paar $(m^*, \sigma^*)$ frisch sein muss, die Nachricht aber nicht unbedingt.

\subsubsection{Definition: sEUF-CMA}\label{sec:sEUF-CMA}
Ein digitales Signaturverfahren $\Sigma = (Gen, Sign, Vfy)$ ist \textit{sEUF-CMA-sicher}, wenn für alle PPT $\mathcal{A}$ gilt, dass
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\mathcal{A}^{\mathcal{C}_\text{sEUF-CMA}}(pk) = (m^*, \sigma^*): \substack{Vfy(pk, m^*, \sigma^*) = 1 \hspace{0.5cm} \land \\ (m^*, \sigma^*) \notin \{(m_1, \sigma_1), \dots, (m_q, \sigma_q)\}}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.\par
Mit einem EUF-CMA-sicheren Signaturverfahren und einer CH-Funktion kann ein sEUF-CMA-sicheres Signaturverfahren konstruiert werden. \textit{Details im Skript.}

\newpage
\section{Pairings und BLS-Signaturen}
\subsection{Pairings}
\subsubsection{Definition}
Seien $\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T$ zyklische Gruppen mit Ordnung $p$ prim. Ein \highlight{Pairing} ist eine \textbf{bilineare} Abbildung
\begin{flalign*}
  \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T
\end{flalign*}
mit den Eigenschaften
\begin{itemize}
  \item{\textbf{Bilinearität}: $\forall g_1, g_1' \in \mathbb{G}_1, g_2, g_2' \in \mathbb{G}_2:$
  \begin{flalign*}
    e(g_1 \cdot g_1', g_2) & = e(g_1, g_2) \cdot e(g_1', g_2) \\
    e(g_1, g_2 \cdot g_2') & = e(g_1, g_2) \cdot e(g_1, g_2')
  \end{flalign*}
  $\Rightarrow e(g_1^a, g_2) = {e(g_1, g_2)}^a = e(g_1, g_2^a)$
  }
  \item{\textbf{Nicht-Ausgeartetheit} (\textit{non-degenerate}): Für Erzeuger $g_1 \in \mathbb{G}_1, g_2 \in \mathbb{G}_2$ gilt:
              \begin{flalign*}
                e(g_1, g_2) \text{ ist Erzeuger von } \mathbb{G}_T \hspace{2cm} (\stackrel{|\mathbb{G}_T| \text{ prim}}{\Longleftrightarrow} e(g_1, g_2) \neq 1)
              \end{flalign*}
        }
  \item{Effiziente Berechenbarkeit}
\end{itemize}
$\mathbb{G}_1, \mathbb{G}_2$ sind in der Regel \textbf{elliptische Kurven}.

\subsubsection{Typen von Pairing}
\begin{enumerate}
  \item{$\mathbb{G}_1 = \mathbb{G}_2$, \textbf{symmetrisches Pairing}
              \begin{flalign*}
                e: \mathbb{G} \times \mathbb{G} \rightarrow \mathbb{G}_T
              \end{flalign*}
        }
  \item{$\mathbb{G}_1 \neq \mathbb{G}_2$, \textbf{asymmetrisches Pairing} und es existiert ein effizienter, nicht-trivialer Homomorphismus
              \begin{flalign*}
                \psi: \mathbb{G}_1 \rightarrow \mathbb{G}_2
              \end{flalign*}
        }
  \item{$\mathbb{G}_1 \neq \mathbb{G}_2$, \textbf{asymmetrisches Pairing} und es existiert \textit{kein} effizienter, nicht-trivialer Homomorphismus
              \begin{flalign*}
                \psi: \mathbb{G}_1 \rightarrow \mathbb{G}_2
              \end{flalign*}
        }
\end{enumerate}

\subsubsection{Diffie-Hellman-Schlüsselaustausch}
\highlight{Diffie-Hellman} ist ein Protokoll, mit dem \textbf{zwei} Parteien einen gemeinsamen geheimen Schlüssel aushandeln können. Setting: Zyklische Gruppe $\mathbb{G} = \langle g \rangle$ mit Ordnung $p$

\begin{tikzpicture}
  \node[circle,draw=black,label={left:$a \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (A) at (0,0) {$A$};
  \node[circle,draw=black,label={right:$b \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (B) at (10,0) {$B$};

  \draw [->] (A) to [out=15,in=165] node[midway,above,inner sep=2pt] {$g^a$} (B);
  \draw [->] (B) to [out=195,in=-15] node[midway,below,inner sep=2pt] {$g^b$} (A);

  \node (keyA) at (0,-2) {$k = {(g^b)}^a = g^{ab}$};
  \node (keyB) at (10,-2) {$k = {(g^a)}^b = g^{ab}$};
\end{tikzpicture}

\textbf{\underline{Ablauf:}}
\begin{enumerate}
  \item{$A$ und $B$ wählen ein zufälliges Element aus $\mathbb{Z}_p$}
  \item{$A$ und $B$ senden dem Gegenüber $g^a$ bzw. $g^b$}
  \item{Beide können sich nun den gemeinsamen Schlüssel $k = g^{ab}$ berechnen}
\end{enumerate}

\subsubsection{Joux 3-Parteien-Schlüsselaustausch}
Joux' Verfahren \cite{jouxKeyExchange} ist ähnlich zu Diffie-Hellman, erlaubt aber einen Schlüsselaustausch zwischen 3 Parteien.\par
\begin{tikzpicture}
  \node[circle,draw=black,label={above:$a \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (A) at (5,0) {$A$};
  \node[circle,draw=black,label={left:$b \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (B) at (0,-5) {$B$};
  \node[circle,draw=black,label={right:$c \stackrel{\$}{\leftarrow} \mathbb{Z}_p$}] (C) at (10,-5) {$C$};

  \draw [->] (A) to [out=210,in=60] node[midway,above,inner sep=2pt] {$g^a$} (B);
  \draw [->] (B) to [out=30,in=240] node[midway,below,inner sep=2pt] {$g^b$} (A);

  \draw [->] (A) to [out=300,in=150] node[midway,left,inner sep=8pt] {$g^a$} (C);
  \draw [->] (C) to [out=120,in=330] node[midway,right,inner sep=8pt] {$g^c$} (A);

  \draw [->] (B) to [out=345,in=195] node[midway,below,inner sep=8pt] {$g^b$} (C);
  \draw [->] (C) to [out=165,in=15] node[midway,above,inner sep=8pt] {$g^c$} (B);

  \node (keyA) at (5,2) {$k = {e(g^b, g^c)}^a = {e(g,g)}^{abc} $};
  \node (keyB) at (0,-7) {$k = {e(g^a, g^c)}^b = {e(g,g)}^{abc}$};
  \node (keyB) at (10,-7) {$k = {e(g^a, g^b)}^c = {e(g,g)}^{abc}$};
\end{tikzpicture}

\textbf{\underline{Ablauf:}}
\begin{enumerate}
  \item{$A$, $B$ und $C$ wählen ein zufälliges Element aus $\mathbb{Z}_p$}
  \item{Alle Teilnehmer senden sich gegenseitig ihre Werte $g^a$, $g^b$ bzw. $g^c$}
  \item{Alle Teilnehmer können sich nun den gemeinsamen Schlüssel $k = {e(g,g)}^{abc}$ berechnen}
\end{enumerate}

\subsection{Boneh-Lynn-Shacham-Signaturen}
\highlight{BLS} ist ein Pairing-basiertes Signaturverfahren mit kurzen Signaturen. Gegeben:
\begin{itemize}
  \item{$\mathbb{G}, \mathbb{G}_T$ Gruppen, $|\mathbb{G}| = |\mathbb{G}_T| = p$ prim, $\langle g \rangle = \mathbb{G}$}
  \item{Symmetrisches Pairing $\mathbb{G} \times \mathbb{G} \rightarrow \mathbb{G}_T$}
  \item{Hashfunktion $H: \{0,1\}^* \rightarrow \mathbb{G}$}
\end{itemize}
Konstruktion:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & x \stackrel{\$}{\leftarrow} \mathbb{Z}_p \\
                 & pk \coloneqq (g, g^x)                    \\
                 & sk \coloneqq x
              \end{flalign*} }
  \item{$Sign(sk,m)$: \begin{flalign*}
                 & \sigma \coloneqq {H(m)}^x \in \mathbb{G}
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                 & e(H(m), g^x) \stackrel{?}{=} e(\sigma, g)
              \end{flalign*}
        }
\end{itemize}
\textbf{Correctness:} $e(H(m), g^x) = {e(H(m), g)}^x = e({H(m)}^x, g) = e(\sigma, g)$\par
BLS-Signaturen sind EUF-CMA-sicher unter der \hyperref[sec:cdh-annahme]{\textbf{CDH-Annahme}} im \hyperref[sec:rom]{\textbf{Random-Oracle-Modell}}.\par
\textit{Sicherheitsbeweis für BLS weggelassen.}

\subsubsection{Aggregierbarkeit}
BLS-Signaturen können \highlight{aggregiert} werden, d.h. zur Verifikation von $(m_1, \sigma_1), \dots, (m_n, \sigma_n)$ müssen nicht alle Signaturen $\sigma_1, \dots, \sigma_n$ mitgeschickt werden, sondern es kann eine aggregierte Signatur $\sigma_{\text{Agg}}$ berechnet werden. Die Gültigkeit kann dann mit $Vfy(pk_1, \dots, pk_n, m_1, \dots, m_n, \sigma_{\text{Agg}}) \stackrel{?}{=} 1$ überprüft werden.\par
Dabei gilt außerdem, dass die aggregierte Signatur genau so lang ist, wie eine einzelne Signatur, also $|\sigma_{\text{Agg}}| = |\sigma|$. Zudem bieten sie einen Effizienzgewinn, da für $n$ Signaturen statt $2n$ nur noch $n + 1$ Pairingauswertungen erforderlich sind.\par
\textbf{\underline{Aggregation:}}
\begin{itemize}
  \item{Signaturen haben die Form ${H(m_i)}^{x_i}$}
  \item{Aggregierer berechnet \begin{flalign*}
                \sigma_{\text{Agg}} = \prod_{i=1}^{n} \sigma_i
              \end{flalign*}
              Aggregation ist öffentlich, es wird kein geheimer Schlüssel benötigt
        }
  \item{Verifikation:\begin{flalign*}
                e(\sigma_{\text{Agg}}, g) \stackrel{?}{=} \prod_{i=1}^{n} e(H(m_i), g^{x_i})
              \end{flalign*}
        }
  \item{Correctness:\begin{flalign*}
                e(\sigma_{\text{Agg}}, g) & = e(\sigma_1, g) \cdot ... \cdot e(\sigma_n, g)             \\
                                          & = e({H(m_1)}^{x_1}, g) \cdot ... \cdot e({H(m_n)}^{x_n}, g) \\
                                          & = e({H(m_1)}, g^{x_1}) \cdot ... \cdot e({H(m_n)}, g^{x_n}) \\
                                          & = \prod_{i=1}^{n} e(H(m_i), g^{x_i})
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Batch-Verifikation}
Ein ähnliches Problem tritt bei der Verifikation auf, bisher verifizieren wir Nachrichten immer einzeln über $Vfy(pk_i, m_i, \sigma_i) \stackrel{?}{=} 1$.\par
Optimaler wäre ein Verfahren, mit dem wir $(m_1, \sigma_1), \dots, (m_n, \sigma_n)$ auf einmal verifizieren können, die Lösung dafür ist die \highlight{Batch-Verifikation}:

\begin{itemize}
  \item{Gegeben: $\sigma_1, \dots, \sigma_n$ Signaturen für $m_1, \dots, m_n$ Nachrichten}
  \item{$h = \prod_{i=1}^{n} H(m_i)$}
  \item{$\sigma = \prod_{i=1}^{n} \sigma_i$}
  \item{Prüfe, ob $e(\sigma, g) \stackrel{?}{=} e(h, g^x)$}
\end{itemize}

\subsection{Computational-Diffie-Hellman-Problem}
\subsubsection{CDH-Problem}
Sei $g$ ein zufälliger Erzeuger und $x, y \stackrel{\$}{\leftarrow} \mathbb{Z}_p$.\par
\highlight{CDH-Problem}: Gegeben $(g, g^x, g^y)$, berechne $g^{xy}$

\subsubsection{CDH-Annahme}\label{sec:cdh-annahme}
$\forall$ PPT $\mathcal{A}$ gilt:
\begin{flalign*}
  \Pr[\mathcal{A}(1^k, g, g^x, g^y) = g^{xy}: g \text{ mit } \langle g \rangle = \mathbb{G} \text{ zufällig}, x, y \stackrel{\$}{\leftarrow} \mathbb{Z}_p] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{Random-Oracle-Modell (ROM)}\label{sec:rom}
Wir betrachten eine idealisierte Hashfunktion $H: \mathcal{D} \rightarrow \mathcal{R}$, bei der die Ausgaben $H(m)$ \textbf{gleichverteilt zufällig} sind für jede Eingabe $m$. H wird als Orakel modelliert, das von allen Teilnehmern benutzt wird und die Hashwerte ausgibt.

\subsubsection{Das H-Orakel}
Das \textbf{H-Orakel} besitzt intern einen \textit{Key-Value-Store} $T$.
Falls es eine Hash-Anfrage für Nachricht $m$ erhält, schaut es in $T$ nach, ob $T[m]$ bereits existiert.
Wenn ja, wird $T[m]$ zurückgegeben, ansonsten wählt das Orakel $y \stackrel{\$}{\leftarrow} \mathcal{R}$, setzt $T[m] \coloneqq y$ und gibt $y$ zurück.

\subsubsection{Diskussion zum ROM}
\begin{itemize}
  \item{Es existiert kein ROM in der realen Welt}
  \item{Manche kryptographischen Probleme sind \textbf{nur} im ROM lösbar}
  \item{Lösungen im ROM sind oft effizienter und einfacher zu konstruieren als im Standardmodell}
  \item{Für viele Konstruktionen im ROM sind keine realen Angriffe bekannt}
\end{itemize}

\section{Waters-Signaturen}
\subsection{Programmierbare Hashfunktionen}
\subsubsection{Definition}
Es sei $H_\kappa: {\{0,1\}}^\ell \rightarrow \mathbb{G}$ eine Hashfunktion und $\mathbb{G}$ eine zyklische, endliche Gruppe mit $g, h$ Erzeuger.\par
Eine \highlight{Programmierbare Hashfunktion} (PHF) ist ein Tupel von 4 (P)PT-Algorithmen
\begin{itemize}
  \item{$Gen(g) \rightarrow \kappa$ \hspace{1cm} (Schlüsselerzeugung)}
  \item{$Eval(\kappa, m) \rightarrow H_\kappa(m)$ \hspace{1cm} (deterministische Auswertung)}
  \item{$TrapGen(g,h) \rightarrow (\kappa, \tau)$ \hspace{1cm} (Schlüsselerzeugung mit Trapdoor)}
  \item{$TrapEval(\tau, m) \rightarrow (a,b)$ mit $h^a g^b = H_\kappa(m)$ \hspace{1cm} (deterministisch)}
\end{itemize}
\textbf{Intuition:} Trapdoor liefert uns ``Zerlegung'' $(a,b)$ von $H_\kappa(m)$, sodass $h^a g^b = H_\kappa(m)$

\subsubsection{Anforderungen an PHF}
\begin{itemize}
  \item{$\kappa$ ist für $Gen$ und $TrapGen$ gleichverteilt, d.h. es ist unmöglich unterscheiden, mit welchem Algorithmus es erstellt wurde}
  \item{\highlight{$(v, w, \gamma)$-Wohlverteilung}: Seien $v, w \in \mathbb{N}, \gamma \in [0,1]$. Für alle
              \begin{itemize}
                \item{Erzeuger $g, h$ von $\mathbb{G}$}
                \item{$m^*_1, \dots, m^*_v \in {\{0, 1\}}^\ell$}
                \item{$m_1, \dots, m_w \in {\{0, 1\}}^\ell$ (alle $m^*_i$ und $m_j$ paarweise verschieden)}
              \end{itemize}
              gilt
              \begin{flalign*}
                \let\scriptstyle\textstyle
                \Pr\Biggl[\substack{a^*_i = 0 \hspace{0.5cm} \forall i = 1, \dots, v \hspace{0.5cm} \land \\ a^*_j = 0 \hspace{0.5cm} \forall j = 1, \dots, w \hspace{0.7cm}}\Biggr] \geq \gamma
              \end{flalign*}
              wobei
              \begin{flalign*}
                (\kappa, \tau) & \leftarrow TrapGen(g,h)                                                \\
                (a^*_i, b^*_i) & \coloneqq TrapEval(\tau, m^*_i) \hspace{0.5cm} \forall i = 1, \dots, v \\
                (a_j, b_j)     & \coloneqq TrapEval(\tau, m_j) \hspace{0.5cm} \forall j = 1, \dots, w   \\
              \end{flalign*}
              Eine $(v, w, \gamma)$-wohlverteilte PHF heißt auch \highlight{$(v, w, \gamma)$-PHF}.
        }
\end{itemize}

\subsubsection{Waters Programmierbare Hashfunktion}
\begin{itemize}
  \item{$Gen(g)$: \begin{flalign*}
                (u_0, \dots, u_\ell) & \stackrel{\$}{\leftarrow} \mathbb{G} \\
                \kappa               & = (u_0, \dots, u_\ell)               \\
              \end{flalign*}
        }
  \item{$Eval(\kappa, m = m_1 \dots m_\ell)$: \begin{flalign*}
                H_\kappa(m) = u_0 \prod_{i = 1}^{\ell} u^{m_i}_i \\
              \end{flalign*}
              ($m_i \in \{0, 1\}$ ist das $i$-te Bit von $m$)\\
              \textbf{Intuition:} $H_\kappa(m)$ ist das Produkt von $u_0$ und aller $u_i$ mit $m_i = 1$
        }
  \item{$TrapGen(g,h)$: \begin{flalign*}
                \hat{a_i} & \stackrel{\$}{\leftarrow} \{-1, 0, 1\} \in \mathbb{Z}_p                             \\
                \hat{b_i} & \stackrel{\$}{\leftarrow} \mathbb{Z}_p                                              \\
                u_i       & \coloneqq h^{\hat{a_i}} g^{\hat{b_i}} \hspace{1cm} \forall i \in \{0, \dots, \ell\} \\
                \kappa    & \coloneqq  (u_0, \dots, u_\ell)                                                     \\
                \tau      & \coloneqq (\hat{a_0}, \dots, \hat{a_\ell}, \hat{b_0}, \dots, \hat{b_\ell})
              \end{flalign*}
        }
  \item{$TrapEval(\tau, m = m_1 \dots m_\ell)$: Berechne \begin{flalign*}
                a & = \hat{a_0} + \sum_{i=1}^\ell m_i \hat{a_i} \hspace{1cm} \text{und} \\
                b & = \hat{b_0} + \sum_{i=1}^\ell m_i \hat{b_i}                         \\
              \end{flalign*}
        }
\end{itemize}
Dann gilt
\begin{flalign*}
  h^a g^b & = h^{\hat{a_0}} \prod_{i = 1}^{\ell} h^{\hat{a_i}m_i} \cdot g^{\hat{b_0}} \prod_{i = 1}^{\ell} g^{\hat{b_i}m_i} \\
          & = (h^{\hat{a_0}} g^{\hat{b_0}}) \cdot \prod_{i = 1}^{\ell} (h^{\hat{a_i}m_i} g^{\hat{b_i}m_i})                  \\
          & = (h^{\hat{a_0}} g^{\hat{b_0}}) \cdot \prod_{i = 1}^{\ell} {(h^{\hat{a_i}} g^{\hat{b_i}})}^{m_i}                \\
          & = u_0 \cdot \prod_{i = 1}^{\ell} {u_i}^{m_i}                                                                    \\
          & = H_\kappa(m)
\end{flalign*}

\subsection{Waters-Signaturen}
\subsubsection{Konstruktion}
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                g^\alpha & \stackrel{\$}{\leftarrow} \mathbb{G}  \\
                \kappa   & \leftarrow Gen_{\text{PHF}}(g)        \\
                sk       & \coloneqq g^\alpha                    \\
                pk       & \coloneqq (g, \kappa, e(g, g^\alpha))
              \end{flalign*}
              (Wir müssen $\alpha$ nicht kennen, da $g$ Erzeuger ist)
        }
  \item{$Sign(sk,m)$: \begin{flalign*}
                r        & \stackrel{\$}{\leftarrow} \mathbb{Z}_p          \\
                \sigma_1 & \coloneqq g^r                                   \\
                \sigma_2 & \coloneqq g^\alpha \cdot {H_\kappa(m)}^r        \\
                \sigma   & \coloneqq (\sigma_1, \sigma_2) \in \mathbb{G}^2
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                 & e(g, \sigma_2) \stackrel{?}{=} e(g, g^\alpha) * e(\sigma_1, H_\kappa(m))
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Korrektheit}
\begin{flalign*}
  e(g, \sigma_2) & =  e(g, g^\alpha \cdot {H_\kappa(m)}^r)            \\
                 & = e(g, g^\alpha) \cdot e(g,  {H_\kappa(m)}^r)      \\
                 & = e(g, g^\alpha) \cdot e(g^r,  {H_\kappa(m)})      \\
                 & = e(g, g^\alpha) \cdot e(\sigma_1,  {H_\kappa(m)}) \\
\end{flalign*}

\subsubsection{Eigenschaften}
\begin{itemize}
  \item{EUF-CMA-sicher unter der \hyperref[sec:cdh-annahme]{\textbf{CDH-Annahme}} im \textbf{Standardmodell}}
  \item{$Gen, Sign, Vfy$ sind effiziente Algorithmen}
  \item{Kleine Signaturen (zwei Gruppenelemente)}
  \item{Public Key enthält $\kappa \coloneqq (u_0, \dots, u_\ell)$ (mit $\ell$ Länge der Nachricht), dadurch \textbf{sehr groß}}
  \item{Bisher ist die $(1, q, \gamma)$-PHF von Walters die einzig bekannte $(1, q, \gamma)$-PHF}
\end{itemize}

\section{RSA-basierte Signaturen}
\subsection{RSA-Problem und -Annahme}
\subsubsection{RSA-Problem}
\textbf{Setting:}
\begin{itemize}
  \item{$P, Q$ ``große'' Primzahlen}
  \item{$N = P \cdot Q$}
  \item{$\varphi(N) = (P-1)(Q-1) = |\mathbb{Z}^*_N|$ (Eulersche Phi-Funktion)}
  \item{Wähle $e \in \mathbb{N}$ zufällig, sodass $\text{ggT}(e, \varphi(N))=1$}
  \item{Dann existiert $d \in \mathbb{N}$ mit $e \cdot d \equiv 1 \mod \varphi(N)$}
  \item{Für $x \in \mathbb{Z}_N$ gilt dann auch $x^{e \cdot d} \equiv x \mod N$}
\end{itemize}
\highlight{RSA-Problem}: Gegeben $N, e$ (wie oben) und $y \stackrel{\$}{\leftarrow} \mathbb{Z}_N$, finde $x \in \mathbb{Z}_N : x^e \equiv y \mod N$

\subsubsection{RSA-Annahme}
Für alle PPT $\mathcal{A}$ gilt:
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\mathcal{A}(1^k, N, e, y) = x: \substack{N = P \cdot Q, e \stackrel{\$}{\leftarrow} \mathbb{Z}^*_{\varphi(N)} \\ y \stackrel{\$}{\leftarrow} \mathbb{Z}_N, x^e \equiv y \mod N}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsection{Strong-RSA-Problem und -Annahme}
\subsubsection{Strong-RSA-Problem}
Viele RSA-Algorithmen sind nur im \hyperref[sec:rom]{Random-Oracle-Modell} sicher. Wir würden allerdings gerne ein EUF-CMA-sicheres Signaturverfahren haben, das auf der RSA-Annahme basiert, aber auch im Standardmodell sicher ist.\par
Dies ist bei einigen Algorithmen mithilfe der \textbf{Strong}-RSA-Annahme gegeben. Das Setting ist analog wie zuvor.\par
\highlight{Strong-RSA-Problem}:  Gegeben \notice{$N$} ``geeignet'' und $y \stackrel{\$}{\leftarrow} \mathbb{Z}_N$, finde $x \in \mathbb{Z}_N$ \notice{und $e \in \mathbb{N}, e > 1$} mit $x^e \equiv y \mod N$\par

\subsubsection{Strong-RSA-Annahme}\label{sec:strongRSAAnnahme}
Für alle PPT $\mathcal{A}$ gilt:
\begin{flalign*}
  \let\scriptstyle\textstyle
  \Pr\Biggl[\mathcal{A}(1^k, N, y) = (x, \notice{e}): \substack{N = P \cdot Q, \notice{e > 1} \\ y \stackrel{\$}{\leftarrow} \mathbb{Z}_N, x^e \equiv y \mod N}\Biggr] \leq negl(k)
\end{flalign*}
für eine im Sicherheitsparameter $k$ vernachlässigbare Funktion $negl$.

\subsubsection{Unterschied zum normalen RSA-Problem und -Annahme}
Die Strong-RSA-Annahme ist \textbf{stärker} als die RSA-Annahme, da der Angreifer mehr Kontrolle hat.\par
Das Strong-RSA-Problem hingegen ist \textbf{schwächer} als das RSA-Problem, da die Gewinnbedingung ``einfacher'' zu erfüllen ist.

\subsection{Textbook-RSA}\label{sec:textbook-rsa}
\subsubsection{Konstruktion}
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & \text{Ziehe zufällige Primzahlen } P, Q              \\
                 & N \coloneqq P \cdot Q                                \\
                 & \text{Wähle } e > 2 \text{ mit ggT}(e, \varphi(N))=1 \\
                 & d \coloneqq e^{-1} \mod \varphi(N)                   \\
                 & pk \coloneqq (N,e)                                   \\
                 & sk \coloneqq d
              \end{flalign*}
        }
  \item{$Sign(sk,m)$: \begin{flalign*}
                \sigma \coloneqq m^d \mod N
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                \sigma^e \stackrel{?}{\equiv} m \mod N
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Korrektheit}
\begin{flalign*}
  \sigma^e \equiv {(m^d)}^e \equiv m^{de \mod \varphi(N)} \equiv m^1 \equiv m \mod N
\end{flalign*}

\subsubsection{Sicherheit}
Textbook-RSA ist \textbf{nicht EUF-1-naCMA-sicher}, da Nachrichten aus zufälligen Signaturen berechnet werden können:
\begin{itemize}
  \item{Wähle $\sigma^* \stackrel{\$}{\leftarrow} \mathbb{Z}_N$}
  \item{Berechne $m^* \coloneqq {(\sigma^*)}^e \mod N$}
  \item{Gebe $(m^*, \sigma^*)$ als Fälschung aus}
\end{itemize}
Für das Verfahren ist keine einzige Signaturanfrage nötig!\par
Zudem ist das Verfahren \textit{homomorph}:
\begin{itemize}
  \item{Seien $\sigma_1, \sigma_2$ gültige Signaturen für $m_1, m_2$}
  \item{Dann ist $\sigma_3 \coloneqq \sigma_1 \sigma_2 \mod N$ gültig für $m_3 \coloneqq m_1 m_2 \mod N$}
  \item{da $\sigma^e_3 \equiv {(\sigma_1 \sigma_2)}^e \equiv \sigma^e_1 \sigma^e_2 \equiv m_1 m_2 \equiv m_3 \mod N$}
\end{itemize}
Zur Konstruktion von sicheren RSA-basierten Signaturen wird häufig die Nachricht vorverarbeitet, bevor signiert wird.

\subsection{RSA Full-Domain-Hash}
\subsubsection{Idee}
Es sei $H \coloneqq {\{0, 1\}}^* \rightarrow \mathbb{Z}_N$ eine kollisionsresistente Hashfunktion.
\begin{itemize}
  \item{Signiere $H(m)$ mit \hyperref[sec:textbook-rsa]{Textbook-RSA}}
  \item{Nachrichtenraum (Domäne) bei Textbook-RSA: $\mathbb{Z}_N$}
  \item{$H$ soll auf die gesamte Domäne $\mathbb{Z}_N$ abbilden (\textbf{Full-Domain-Hash})}
\end{itemize}

\subsubsection{Konstruktion}
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & \text{Wie bei Textbook-RSA, außer} \\
                 & pk \coloneqq (N,e, \notice{H})
              \end{flalign*}
        }
  \item{$Sign(sk,m)$: \begin{flalign*}
                \sigma \coloneqq \notice{H(}m\notice{)}^d \mod N
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                \sigma^e \stackrel{?}{\equiv} \notice{H(}m\notice{)} \mod N
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Korrektheit}
\begin{flalign*}
  \sigma^e \equiv {({H(m)}^d)}^e \equiv {H(m)}^{de \mod \varphi(N)} \equiv {H(m)}^1 \equiv H(m) \mod N
\end{flalign*}

\subsubsection{Sicherheit}
Wenn die RSA-Annahme gilt, dann ist das RSA-FDH EUF-CMA-sicher im \hyperref[sec:rom]{Random-Oracle-Modell}.

\subsection{RSA-PSS}
Bei \textbf{RSA-PSS} wird die Nachricht vorverarbeitet und dann signiert.

\subsubsection{Konstruktion}
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                \text{Wie bei Textbook-RSA}
              \end{flalign*}
        }
  \item{$Sign(sk,m)$: \begin{flalign*}
                \sigma \coloneqq \text{PSS-Encode}{(m)}^d \mod N
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                 & \text{Berechne } y = \sigma^e \mod N                           \\
                 & \text{Gib $1$ aus gdw. $y$ eine gültige Codierung von $m$ ist}
              \end{flalign*}
        }
\end{itemize}

\subsection{GHR-Signaturen}
\subsubsection{Konstruktion}
Gennaro-Halevi-Rabin-Signaturen (\textbf{GHR-Signaturen}) basieren auf der \hyperref[sec:strongRSAAnnahme]{Strong-RSA-Annahme} und benötigen (anders als die vorherigen Verfahren) kein ROM.\par
Es sei $H \coloneqq {\{0, 1\}}^* \rightarrow \mathbb{P}$ eine Hashfunktion ($\mathbb{P} =$ Primzahlen).
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                 & \text{Ziehe zufällige Primzahlen } P, Q                                              \\
                 & N \coloneqq P \cdot Q                                                                \\
                 & s \stackrel{\$}{\leftarrow} \mathbb{Z}_N                                             \\
                 & \text{Wähle } h \text{ so, dass für alle $m$ ggT}(h(m), \varphi(N)) = 1 \text{ gilt} \\
                 & pk \coloneqq (N,s,h)                                                                 \\
                 & sk \coloneqq \varphi(N) = (P-1)(Q-1)
              \end{flalign*}
        }
  \item{$Sign(sk,m)$: \begin{flalign*}
                \sigma \coloneqq s^{1 / h(m)} \mod N
              \end{flalign*} }
  \item{$Vfy(pk, m, \sigma)$: \begin{flalign*}
                \sigma^{h(m)} \stackrel{?}{\equiv} s \mod N
              \end{flalign*}
        }
\end{itemize}

\subsubsection{Hashfunktionen für GHR-Signaturen}
Wir haben zwei Bedingungen an unsere Hashfunktion $h$:
\begin{enumerate}
  \item{$h$ muss auf Primzahlen abbilden}
  \item{$h$ muss so gewählt sein, dass für alle $m$ ggT$(h(m), \varphi(N)) = 1$ gilt}
\end{enumerate}

\subsubsection{Hashfunktionen, die auf Primzahlen abbilden}
Hashfunktionen, die auf Primzahlen abbilden, können wie folgt konstruiert werden:
\begin{itemize}
  \item{Sei $H: {\{0,1\}}^* \rightarrow {\{0,1\}}^\ell$ eine kollisionsresistente Hashfunktion}
  \item{Annahme: $H$ bildet ``einigermaßen gleichverteilt'' nach ${\{0,1\}}^\ell$ ab}
  \item{Definiere $h: {\{0,1\}}^* \rightarrow \mathbb{P} \cap {\{0,1\}}^\ell$ durch \begin{flalign*}
    h(m) \coloneqq H(m \parallel \gamma)
  \end{flalign*}
  mit $\gamma \in \mathbb{N}$ kleinste Zahl, sodass $H(m \parallel \gamma)$ prim.}
  \item{$\gamma$ kann bei der Auswertung von $h$ durch Hochzählen gefunden werden}
\end{itemize}

\subsubsection{Hashfunktionen, für die für alle \texorpdfstring{$m$}{} gilt, dass \texorpdfstring{ggT$(h(m), \varphi(N)) = 1$}{}}
Die Bedingung kann mit der Verwendung von \highlight{Strong Primes} erfüllt werden:
\begin{itemize}
  \item{Primzahl $P$ ist eine Strong Prime $\Leftrightarrow$ Es existiert eine Primzahl $p$ mit $P = 2p + 1$}
  \item{Wähle Strong Primes $P = 2p + 1,Q = 2q + 1$}
  \item{$N = P \cdot Q$}
  \item{Dann gilt $\varphi(N) = 4 \cdot p \cdot q$}
  \item{Wähle $p,q$ so, dass sie keine Ausgabe von $H$ sind (z.B. $p, q > 2^\ell$)}
  \item{Passe $H$ so an, dass $2$ und $4$ keine möglichen Hashwerte sind}
\end{itemize}

\section{Message Authentication Codes}
Bei den bisher vorgestellten Signaturverfahren handelt es sich um \hyperref[sec:signaturenDefinition]{asymmetrische Verfahren}, die ein \textbf{Schlüsselpaar} $(sk, pk)$ verwendet haben.\par
Message Authentication Codes (\highlight{MAC}s) werden ebenfalls zur Sicherstellung der Authentizität und Integrität von Nachrichten verwendet, basieren aber auf einem \textbf{symmetrischen} System, bei dem das Authentifizieren \textbf{und} das Verifizieren mit dem gleichen Schlüssel $\kappa$ geschieht.

\subsection{Grundlagen}
\subsubsection{Definition}
Ein \textbf{Message Authentication Code} (MAC) $\Pi$ ist ein Tupel $(Gen, Sign, Vfy)$ von (P)PT-Algorithmen:
\begin{itemize}
  \item{$Gen(1^k) \rightarrow \kappa$}
  \item{$Sign(\kappa, m) \rightarrow t$, $m \in {\{0,1\}}^*$}
  \item{$Vfy(\kappa, m, t) \in \{0, 1\}$}
\end{itemize}
\textbf{Korrektheit:} $\forall \kappa \leftarrow Gen(1^k) \forall m \in {\{0,1\}}^*: Vfy(\kappa, m, Sign(\kappa, m)) = 1$\par
$Sign$ kann entweder probabilistisch oder deterministisch sein, der MAC wird dann je nach Fall als \textbf{probabilistischer MAC} oder \textbf{deterministischer MAC} bezeichnet. $t$ wird ``MAC'' oder ``Tag'' genannt.

\subsubsection{Fixed- und variable-length MACs}
\highlight{Fixed-length MAC}: Es gibt eine Funktion $\ell$, sodass für alle $\kappa \leftarrow Gen(1^k)$ der $Sign$-Algorithmus nur für Nachrichten $m \in {\{0,1\}}^{\ell(k)}$ definiert ist.\par
MACs mit variabler Nachrichtenlänge werden \highlight{variable-length MAC}s genannt.

\subsubsection{Kanonische Verifikation}\label{sec:kanonischeVerifikation}
Bei deterministischen MACs kann die Verifikation erfolgen, indem das Tag einfach neu berechnet wird:\par
$Vfy(\kappa, m, t):$
\begin{itemize}
  \item{$\tilde{t} \coloneqq Sign(\kappa, m)$}
  \item{\texttt{return} $\tilde{t} \stackrel{?}{=} t$}
\end{itemize}

\subsection{Sicherheitsbegriffe für MACs}
Die Sicherheitsbegriffe \hyperref[sec:euf-cma]{\textbf{EUF-CMA}} und \hyperref[sec:sEUF-CMA]{\textbf{sEUF-CMA}} sind analog zu den Sicherheitsbegriffen für Digitale Signaturen definiert.
Bei den jeweiligen Sicherheitsexperimenten sendet der Challenger am Anfang jedoch nun keine Nachricht mehr, da es keinen $pk$ mehr gibt, sondern nur noch einen Schlüssel $\kappa$.\par
sEUF-CMA-sichere MACS werden \highlight{strong MACs} genannt.

\subsubsection{strong MACs durch eindeutige Tags}
Ein MAC-Verfahren hat \textbf{eindeutige Tags} $\Leftrightarrow$ Für $\kappa$ und $m$ gibt es genau einen Tag $t$ mit $Vfy(\kappa, m, t) = 1$.\par
Ein EUF-CMA-sicherer MAC $\Pi$ mit eindeutigen Tags ist sEUF-CMA-sicher.

\subsubsection{Anmerkungen zu eindeutigen Tags}
\begin{itemize}
  \item{MACs, die die kanonische Verifikation verwenden, haben eindeutige Tags}
  \item{Deterministische MACs haben eindeutige Tags}
\end{itemize}

\subsection{Konstruktion von MACs aus PRFs}
\subsubsection{Konstruktion eines fixed-length MAC}
Es sei $PRF: {\{0, 1\}}^k \times {\{0, 1\}}^k \rightarrow {\{0, 1\}}^k$ eine PRF. Definiere MAC $\Pi$ für Nachrichten $m \in {\{0, 1\}}^k$ wie folgt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                \kappa \stackrel{\$}{\leftarrow} {\{0, 1\}}^k
              \end{flalign*}
        }
  \item{$Sign(\kappa, m)$: \begin{flalign*}
                t \leftarrow PRF(\kappa,m)
              \end{flalign*}
        }
  \item{$Vfy(\kappa, m, t)$: (\hyperref[sec:kanonischeVerifikation]{\textit{kanonisch}})\begin{flalign*}
                 & \tilde{t} \coloneqq Sign(\kappa, m) \\
                 & \tilde{t} \stackrel{?}{=} t
              \end{flalign*}}
\end{itemize}

\newpage
\subsubsection{Erweiterung auf variable-length MAC}
Analog zu Signaturen kann auch bei MACs das \hyperref[sec:hash-then-sign]{Hash-then-Sign}-Paradigma verwendet werden.\par
Es sei $H: {\{0, 1\}}^* \rightarrow {\{0, 1\}}^k$ eine Hashfunktion und $\Pi' = (Gen', Sign', Vfy')$ ein fixed-length MAC für Nachrichten $m \in {\{0, 1\}}^k$. Definiere den variable-length MAC $\Pi$ für Nachrichten $m \in {\{0, 1\}}^*$ wie folgt:
\begin{itemize}
  \item{$Gen(1^k)$: \begin{flalign*}
                \kappa \leftarrow Gen'(1^k)
              \end{flalign*}
        }
  \item{$Sign(\kappa, m)$: \begin{flalign*}
                t \leftarrow Sign'(\kappa, H(m))
              \end{flalign*}
        }
  \item{$Vfy(\kappa, m, t)$: \begin{flalign*}
                 & b \leftarrow Vfy'(\kappa, H(m), t) \\
                 & b \stackrel{?}{=} 1
              \end{flalign*}}
\end{itemize}

\newpage
\bibliographystyle{apalike}
\bibliography{\jobname}
\end{document}